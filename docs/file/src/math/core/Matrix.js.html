<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/math/core/Matrix.js | konpeito_es3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito_es3"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito-ES3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-konpeitoES3">konpeitoES3</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core">math/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Complex.js~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KComplexInputData">KComplexInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixInputData">KMatrixInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixSettings">KMatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-tools">math/core/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/LinearAlgebra.js~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Probability.js~Probability.html">Probability</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Signal.js~Signal.html">Signal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KSignalSettings">KSignalSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KStatisticsSettings">KStatisticsSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis.js~DataAnalysis.html">DataAnalysis</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools-dataanalysis">math/tools/DataAnalysis</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/MultipleRegressionAnalysis.js~MultipleRegressionAnalysis.html">MultipleRegressionAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/PrincipalComponentAnalysis.js~PrincipalComponentAnalysis.html">PrincipalComponentAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisAnova">KMultipleRegressionAnalysisAnova</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisOutput">KMultipleRegressionAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegression">KMultipleRegressionAnalysisPartialRegression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegressionData">KMultipleRegressionAnalysisPartialRegressionData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisSettings">KMultipleRegressionAnalysisSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisVectorState">KMultipleRegressionAnalysisVectorState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponent">KPrincipalComponent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisOutput">KPrincipalComponentAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisSettings">KPrincipalComponentAnalysisSettings</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/core/Matrix.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito-ES3.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */

import Polyfill from &quot;../tools/Polyfill.js&quot;;
import LinearAlgebra from &quot;./tools/LinearAlgebra.js&quot;;
import Statistics from &quot;./tools/Statistics.js&quot;;
import Signal from &quot;./tools/Signal.js&quot;;
import Complex from &quot;./Complex.js&quot;;
import Random from &quot;./tools/Random.js&quot;;

/**
 * @param {any} obj 
 * @returns {boolean} 
 * @private
 */
const instanceofComplex = function(obj) {
	return obj.isComplexData ? obj.isComplexData() : false;
}

/**
 * @param {any} obj 
 * @returns {boolean} 
 * @private
 */
 const instanceofMatrix = function(obj) {
	return obj.isMatrixData ? obj.isMatrixData() : false;
}

/**
 * Matrix type argument.
 * - Matrix
 * - Complex
 * - number
 * - string
 * - Array&lt;string|number|Complex|Matrix&gt;
 * - Array&lt;Array&lt;string|number|Complex|Matrix&gt;&gt;
 * - {doubleValue:number}
 * - {toString:function}
 * 
 * Initialization can be performed as follows.
 * - 10, &quot;10&quot;, &quot;3 + 4j&quot;, &quot;[ 1 ]&quot;, &quot;[1, 2, 3]&quot;, &quot;[1 2 3]&quot;, [1, 2, 3],
 * - [[1, 2], [3, 4]], &quot;[1 2; 3 4]&quot;, &quot;[1+2i 3+4i]&quot;,
 * - &quot;[1:10]&quot;, &quot;[1:2:3]&quot; (MATLAB / Octave / Scilab compatible).
 * @typedef {Matrix|Complex|number|string|Array&lt;string|number|Complex|Matrix&gt;|Array&lt;Array&lt;string|number|Complex|Matrix&gt;&gt;|{doubleValue:number}|{toString:function}} KMatrixInputData
 */

/**
 * Collection of calculation settings for matrix.
 * - Available options vary depending on the method.
 * @typedef {Object} KMatrixSettings
 * @property {?string|?number} [dimension=&quot;auto&quot;] Calculation direction. 0/&quot;auto&quot;, 1/&quot;row&quot;, 2/&quot;column&quot;, 3/&quot;both&quot;.
 * @property {Object} [correction] Correction value. For statistics. 0(unbiased), 1(sample).
 */

/**
 * Collection of functions used in Matrix.
 * @ignore
 */
class MatrixTool {

	/**
	 * Create actual values from data specifying matrix position.
	 * @param {any} data - A value indicating the position in a matrix.
	 * @param {number} max - Length to initialize. (Used when &quot;:&quot; is specified at matrix creation.)
	 * @param {number} geta - Offset at initialization. (Used when &quot;:&quot; is specified at matrix creation.)
	 * @returns {Array&lt;number&gt;}
	 */
	static toPositionArrayFromObject(data, max, geta) {
		if(typeof data === &quot;string&quot;) {
			const array_or_string = MatrixTool.toArrayFromString(data);
			if(array_or_string === &quot;:&quot;) {
				// : &#x304C;&#x6307;&#x5B9A;&#x3055;&#x308C;&#x305F;&#x5834;&#x5408;
				const y = new Array(max);
				for(let i = 0; i &lt; max; i++) {
					y[i] =  i + geta;
				}
				return y;
			}
			else if(array_or_string instanceof Array) {
				// &#x8907;&#x7D20;&#x6570;&#x306E;&#x914D;&#x5217;&#x304B;&#x3089;&#x4E2D;&#x8EAB;&#x3092;&#x53D6;&#x308A;&#x51FA;&#x3059;
				const y = array_or_string;
				const num_y = new Array(y.length);
				for(let i = 0; i &lt; y.length; i++) {
					num_y[i] = Math.trunc(y[i].real());
				}
				return num_y;
			}
			else {
				throw &quot;toArrayFromString[&quot; + data + &quot;][&quot; + array_or_string + &quot;]&quot;;
			}
		}
		let t_data = data;
		if(!(instanceofMatrix(t_data)) &amp;&amp; !(instanceofComplex(t_data)) &amp;&amp; !((typeof t_data === &quot;number&quot;))) {
			t_data = Matrix._toMatrix(t_data);
		}
		if(instanceofMatrix(t_data)) {
			if(!t_data.isVector()) {
				throw &quot;getMatrix argument &quot; + t_data;
			}
			const len = t_data.length();
			const y = new Array(t_data.length());
			if(t_data.isRow()) {
				for(let i = 0; i &lt; len; i++) {
					y[i] = Math.trunc(t_data.matrix_array[0][i].real());
				}
			}
			else if(t_data.isColumn()) {
				for(let i = 0; i &lt; len; i++) {
					y[i] = Math.trunc(t_data.matrix_array[i][0].real());
				}
			}
			return y;
		}
		return [ Matrix._toInteger(t_data) ];
	}

	/**
	 * A match function that can also extract strings excluding matched strings.
	 * @param {string} text - Search target.
	 * @param {RegExp} regexp - Regular expression.
	 * @returns {Array&lt;Object&lt;boolean, string&gt;&gt;}
	 */
	static match2(text, regexp) {
		// &#x5BFE;&#x8C61;&#x3067;&#x306F;&#x306A;&#x3044;regexp&#x306E;&#x60C5;&#x5831;&#x4EE5;&#x5916;&#x3082;&#x62BD;&#x51FA;match
		// &#x3064;&#x307E;&#x308A; &quot;1a2b&quot; &#x3067; \d &#x3092;&#x62BD;&#x51FA;&#x3059;&#x308B;&#x3068;&#x3001;&#x6B21;&#x306E;&#x3088;&#x3046;&#x306B;&#x62BD;&#x51FA;&#x3055;&#x308C;&#x308B;
		// [false &quot;1&quot;]
		// [true &quot;a&quot;]
		// [false &quot;2&quot;]
		// [true &quot;b&quot;]
		// 0 ... &#x4E00;&#x81F4;&#x3057;&#x305F;&#x304B;&#x3069;&#x3046;&#x304B;
		// 1 ... &#x4E00;&#x81F4;&#x3057;&#x305F;&#x6587;&#x5B57;&#x5217;&#x3001;&#x3042;&#x308B;&#x3044;&#x306F;&#x4E00;&#x81F4;&#x3057;&#x3066;&#x3044;&#x306A;&#x3044;&#x6587;&#x5B57;&#x5217;
		const output = [];
		let search_target = text;
		for(let x = 0; x &lt; 1000; x++) {
			const match = search_target.match(regexp);
			if(match === null) {
				if(search_target.length) {
					output.push([ false, search_target ]);
				}
				break;
			}
			if(match.index &gt; 0) {
				output.push([ false, search_target.substr(0, match.index) ]);
			}
			output.push([ true, match[0] ]);
			search_target = search_target.substr(match.index + match[0].length);
		}
		return output;
	}
	
	/**
	 * Removed front and back brackets when enclosed by brackets.
	 * - Return null if the string has no brackets.
	 * @param {string} text - String to be processed.
	 * @returns {{text : string, is_transpose : boolean}|null} String after brackets removal or null.
	 */
	static trimBracket(text) {
		let input_text = text;
		let is_transpose = false;
		// &#x5F8C;&#x308D;&#x306B;&apos;&#x304C;&#x4ED8;&#x3044;&#x3066;&#x3044;&#x308B;&#x304B;&#x3069;&#x3046;&#x304B;&#x691C;&#x77E5;(&#x8EE2;&#x7F6E;&#x884C;&#x5217;&#x7528;)
		if(/&apos;$/.test(input_text)) {
			const dash_text = input_text.match(/(\s*&apos;)*$/g)[0];
			const dash_count = (dash_text.split(&quot;&apos;&quot;).length - 1);
			is_transpose = (dash_count % 2) === 1;
			input_text = input_text.substring(0, input_text.length - dash_text.length);
		}
		// &#x524D;&#x5F8C;&#x306B;[]&#x304C;&#x3042;&#x308B;&#x304B;&#x78BA;&#x8A8D;
		if( !(/^\[/).test(input_text) || !(/\]$/).test(input_text)) {
			return null;
		}
		// &#x524D;&#x5F8C;&#x306E;[]&#x3092;&#x9664;&#x53BB;
		return {
			text : input_text.substring(1, input_text.length - 1),
			is_transpose : is_transpose
		};
	}

	/**
	 * Create Matrix type data from string data defined in JSON.
	 * - For example, &quot;[xx,xx,xx], [xx,xx,xx]&quot;
	 * @param {string} text - String to be processed.
	 * @returns {Array&lt;Array&lt;Complex&gt;&gt;} Internal array used by Matrix type.
	 */
	static toMatrixArrayFromStringForArrayJSON(text) {
		const matrix_array = [];
		// &#x3055;&#x3089;&#x306B;&#x30D6;&#x30E9;&#x30F3;&#x30B1;&#x30C3;&#x30C8;&#x5185;&#x3092;&#x62BD;&#x51FA;
		let rows = text.match(/\[[^\]]+\]/g);
		if(rows === null) {
			// &#x30D6;&#x30E9;&#x30F3;&#x30B1;&#x30C3;&#x30C8;&#x304C;&#x306A;&#x3044;&#x5834;&#x5408;&#x306F;&#x3001;1&#x884C;&#x884C;&#x5217;&#x3067;&#x3042;&#x308B;
			rows = [text];
		}
		// &#x5404;&#x30D6;&#x30E9;&#x30F3;&#x30B1;&#x30C3;&#x30C8;&#x5185;&#x3092;&#x5217;&#x3054;&#x3068;&#x306B;&#x8ABF;&#x67FB;
		for(let row_count = 0; row_count &lt; rows.length; row_count++) {
			const row = rows[row_count];
			const column_array = row.substring(1, row.length - 1).split(&quot;,&quot;);
			const rows_array = [];
			for(let col_count = 0; col_count &lt; column_array.length; col_count++) {
				const column = column_array[col_count];
				rows_array[col_count] = new Complex(column);
			}
			matrix_array[row_count] = rows_array;
		}
		return matrix_array;
	}

	/**
	 * Create a numeric array from initial values, difference values, and final values.
	 * @param {Complex} from - Start value.
	 * @param {Complex} delta - Delta.
	 * @param {Complex} to - End value.
	 * @param {boolean} [is_include_last_number=true] - Whether to include the last value.
	 * @returns {Array&lt;Complex&gt;}
	 */
	static InterpolationCalculation(from, delta, to, is_include_last_number) {
		const FromIsGreaterThanTo = from.compareTo(to);
		const is_include_last_number_ = is_include_last_number !== undefined ? is_include_last_number : true;
		if(FromIsGreaterThanTo === 0) {
			return [from];
		}
		if(delta.isZero()) {
			throw &quot;IllegalArgumentException&quot;;
		}
		// delta &#x304C;&#x8CA0;&#x306E;&#x305F;&#x3081;&#x3001;&#x3069;&#x308C;&#x3060;&#x3051;&#x305F;&#x3057;&#x3066;&#x3082; to &#x306B;&#x306A;&#x3089;&#x306A;&#x3044;&#x3002;
		if(delta.isNegative() &amp;&amp; (FromIsGreaterThanTo === -1)) {
			throw &quot;IllegalArgumentException&quot;;
		}
		// FromIsGreaterThanTo
		// +1 from &#x306E;&#x65B9;&#x304C;&#x5927;&#x304D;&#x3044;&#x3002;&#x4E0B;&#x306B;&#x6E1B;&#x7B97;&#x30BF;&#x30A4;&#x30D7;
		// -1 to &#x306E;&#x65B9;&#x304C;&#x5927;&#x304D;&#x3044;&#x3002;&#x4E0A;&#x306B;&#x52A0;&#x7B97;&#x30BF;&#x30A4;&#x30D7;
		const rows_array = [];
		let num = from;
		rows_array[0] = num;
		for(let i = 1; i &lt; 0x10000; i++) {
			num = num.add(delta);
			if(is_include_last_number_) {
				if(to.compareTo(num) === FromIsGreaterThanTo) {
					break;
				}
			}
			else {
				if((to.compareTo(num) * FromIsGreaterThanTo) &gt;= 0) {
					break;
				}
			}
			rows_array[i] = num;
		}
		return rows_array;
	}

	/**
	 * Create an array of numbers from data separated by match2.
	 * @param {Array&lt;Object&lt;boolean, string&gt;&gt;} match2_string - Data separated by &quot;toArrayFromString&quot;.
	 * @returns {Array&lt;Complex&gt;}
	 */
	static toArrayFromMatch2String(match2_string) {
		const xs = match2_string;
		const rows_array = [];
		for(let i = 0; i &lt; xs.length; i++) {
			const xx = xs[i];
			if(!xx[0]) {
				// &#x4E00;&#x81F4;&#x3057;&#x3066;&#x3044;&#x306A;&#x3044;&#x30C7;&#x30FC;&#x30BF;&#x3067;&#x3042;&#x308C;&#x3070;&#x6B21;&#x3078;
				continue;
			}
			// &#x300C;:&#x8A18;&#x6CD5;&#x300D; 1:3 &#x306A;&#x3089; 1,2,3&#x3002; 1:2:9 &#x306A;&#x3089; 1:3:5:7:9
			if((i &lt; xs.length - 2) &amp;&amp; !xs[i + 1][0] &amp;&amp; /:/.test(xs[i + 1][1])) {
				let from, delta, to;
				if((i &lt; xs.length - 4) &amp;&amp; !xs[i + 3][0] &amp;&amp; /:/.test(xs[i + 3][1])) {
					from = new Complex(xx[1]);
					delta = new Complex(xs[i + 2][1]);
					to = new Complex(xs[i + 4][1]);
					i += 4;
				}
				else {
					from = new Complex(xx[1]);
					delta = Complex.ONE;
					to = new Complex(xs[i + 2][1]);
					i += 2;
				}
				const ip_array = MatrixTool.InterpolationCalculation(from, delta, to, true);
				for(let j = 0; j &lt; ip_array.length; j++) {
					rows_array.push(ip_array[j]);
				}
			}
			else {
				rows_array.push(new Complex(xx[1]));
			}
		}

		return rows_array;
	}

	/**
	 * Convert string to row part of matrix type matrix data.
	 * Estimate the matrix by extracting parts like numbers.
	 * @param {string} row_text - A string describing one row of the matrix.
	 * @returns {Array&lt;Complex&gt;|string}
	 */
	static toArrayFromString(row_text) {
		// &#x300C;:&#x300D;&#x306E;&#x307F;&#x8A18;&#x8F09;&#x3055;&#x308C;&#x3066;&#x3044;&#x306A;&#x3044;&#x304B;&#x306E;&#x78BA;&#x8A8D;
		if(row_text.trim() === &quot;:&quot;) {
			return &quot;:&quot;;
		}
		const str = row_text.toLowerCase().replace(/infinity|inf/g, &quot;1e100000&quot;);
		// &#x5DE6;&#x304C;&#x5B9F;&#x6570;&#xFF08;&#x5F37;&#x5236;&#xFF09;&#x3067;&#x53F3;&#x304C;&#x8907;&#x7D20;&#x6570;&#xFF08;&#x4EFB;&#x610F;&#xFF09;&#x30BF;&#x30A4;&#x30D7;
		const reg1 = /[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))( *[+-] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij])?/;
		// &#x5DE6;&#x304C;&#x8907;&#x7D20;&#x6570;&#xFF08;&#x5F37;&#x5236;&#xFF09;&#x3067;&#x53F3;&#x304C;&#x5B9F;&#x6570;&#xFF08;&#x4EFB;&#x610F;&#xFF09;&#x30BF;&#x30A4;&#x30D7;
		const reg2 = /[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]( *[+] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan)))?/;
		// reg2&#x512A;&#x5148;&#x3067;&#x691C;&#x7D22;
		const reg3 = new RegExp(&quot;(&quot; + reg2.source + &quot;)|(&quot; + reg1.source + &quot;)&quot;, &quot;i&quot;);
		// &#x554F;&#x984C;&#x3068;&#x3057;&#x3066; 1 - -j&#x304C;&#x901A;&#x308B;
		return MatrixTool.toArrayFromMatch2String(MatrixTool.match2(str, reg3));
	}

	/**
	 * Create Matrix type data from string data defined by character string with space separation etc.
	 * @param {string} text - Strings to analyze.
	 * @returns {Array&lt;Array&lt;Complex&gt;&gt;} Internal array used by Matrix type.
	 */
	static toMatrixArrayFromStringForArraySPACE(text) {
		// &#x884C;&#x3054;&#x3068;&#x3092;&#x62BD;&#x51FA;&#x3057;&#x3066;
		const rows = text.split(&quot;;&quot;);
		const matrix_array = new Array(rows.length);
		for(let row_count = 0; row_count &lt; rows.length; row_count++) {
			// &#x5404;&#x884C;&#x306E;&#x6587;&#x5B57;&#x3092;&#x89E3;&#x6790;
			matrix_array[row_count] = MatrixTool.toArrayFromString(rows[row_count]);
		}
		return matrix_array;
	}

	/**
	 * Create Matrix type data composed of string data for matrix.
	 * @param {string} text - Strings to analyze.
	 * @returns {Array&lt;Array&lt;Complex&gt;&gt;} Internal array used by Matrix type.
	 */
	static toMatrixArrayFromStringInBracket(text) {
		// &#x30D6;&#x30E9;&#x30B1;&#x30C3;&#x30C8;&#x306E;&#x4E2D;&#x306B;&#x30D6;&#x30E9;&#x30B1;&#x30C3;&#x30C8;&#x304C;&#x3042;&#x308B;&#xFF1D;JSON&#x5F62;&#x5F0F;
		if(/[[\]]/.test(text)) {
			return MatrixTool.toMatrixArrayFromStringForArrayJSON(text);
		}
		// &#x305D;&#x308C;&#x4EE5;&#x5916;(MATLAB, Octave, Scilab)
		else {
			return MatrixTool.toMatrixArrayFromStringForArraySPACE(text);
		}
	}

	/**
	 * Create Matrix type data from string data.
	 * @param {string} text - Strings to analyze.
	 * @returns {Array&lt;Array&lt;Complex&gt;&gt;} Internal array used by Matrix type.
	 */
	static toMatrixArrayFromString(text) {
		// &#x524D;&#x5F8C;&#x306E;&#x30B9;&#x30DA;&#x30FC;&#x30B9;&#x3092;&#x9664;&#x53BB;
		const trimtext = text.replace(/^\s*|\s*$/g, &quot;&quot;);
		// &#x30D6;&#x30E9;&#x30B1;&#x30C3;&#x30C8;&#x3092;&#x5916;&#x3059;
		const withoutBracket = MatrixTool.trimBracket(trimtext);
		if(withoutBracket) {
			// &#x914D;&#x5217;&#x7528;&#x306E;&#x521D;&#x671F;&#x5316;
			let array_data = MatrixTool.toMatrixArrayFromStringInBracket(withoutBracket.text);
			// &#x8EE2;&#x7F6E;&#x304C;&#x5FC5;&#x8981;&#x306A;&#x3089;&#x8EE2;&#x7F6E;&#x3055;&#x305B;&#x308B;
			if(withoutBracket.is_transpose) {
				array_data = (new Matrix(array_data)).T().matrix_array;
			}
			return array_data;
		}
		// &#x30D6;&#x30E9;&#x30B1;&#x30C3;&#x30C8;&#x304C;&#x306A;&#x3044;&#x304C;&#x3001;; &#x3084; , &#x304C;&#x542B;&#x307E;&#x308C;&#x3066;&#x3044;&#x305F;&#x308A;&#x3001;&#x6570;&#x5B57;&#x3068;&#x6570;&#x5B57;&#x306B;&#x30B9;&#x30DA;&#x30FC;&#x30B9;&#x304C;&#x3042;&#x308B;&#x5834;&#x5408;&#x306F;&#x914D;&#x5217;&#x3068;&#x3057;&#x3066;&#x307F;&#x306A;&#x3059;
		else if(/[;,]|[0-9]\s+[0-9]/.test(text)) {
			return MatrixTool.toMatrixArrayFromStringInBracket(text.replace(/[[\]]/g, &quot;&quot;).replace(/,/g, &quot; &quot;));
		}
		else {
			// &#x30B9;&#x30AB;&#x30E9;&#x30FC;&#x7528;&#x306E;&#x521D;&#x671F;&#x5316;
			return [[new Complex(text)]];
		}
	}

	/**
	 * Returns true if Matrix type internal data is correct as matrix data.
	 * @param {Array&lt;Array&lt;Complex&gt;&gt;} m_array
	 * @returns {boolean} 
	 */
	static isCorrectMatrixArray(m_array) {
		if(m_array.length === 0) {
			return false;
		}
		const num = m_array[0].length;
		if(num === 0) {
			return false;
		}
		for(let i = 1; i &lt; m_array.length; i++) {
			if(m_array[i].length !== num) {
				return false;
			}
		}
		return true;
	}
}

/**
 * Complex matrix class. (immutable)
 */
export default class Matrix {
	
	/**
	 * Create a complex matrix.
	 * Initialization can be performed as follows.
	 * - 10, &quot;10&quot;, &quot;3 + 4j&quot;, &quot;[ 1 ]&quot;, &quot;[1, 2, 3]&quot;, &quot;[1 2 3]&quot;, [1, 2, 3],
	 * - [[1, 2], [3, 4]], &quot;[1 2; 3 4]&quot;, &quot;[1+2i 3+4i]&quot;,
	 * - &quot;[1:10]&quot;, &quot;[1:2:3]&quot; (MATLAB / Octave / Scilab compatible).
	 * @param {KMatrixInputData} number - Complex matrix. See how to use the function.
	 */
	constructor(number) {
		let matrix_array = null;
		let is_check_string = false;
		if(arguments.length === 1) {
			const obj = number;
			// &#x884C;&#x5217;&#x578B;&#x306A;&#x3089;&#x4E2D;&#x8EAB;&#x3092;&#x30C7;&#x30A3;&#x30FC;&#x30D7;&#x30B3;&#x30D4;&#x30FC;&#x3059;&#x308B;
			if(instanceofMatrix(obj)) {
				matrix_array = new Array(obj.row_length);
				for(let i = 0; i &lt; obj.row_length; i++) {
					matrix_array[i] = new Array(obj.column_length);
					for(let j = 0; j &lt; obj.column_length; j++) {
						matrix_array[i][j] = obj.matrix_array[i][j];
					}
				}
			}
			// &#x8907;&#x7D20;&#x6570;&#x578B;&#x306A;&#x3089;1&#x8981;&#x7D20;&#x306E;&#x884C;&#x5217;
			else if(instanceofComplex(obj)) {
				matrix_array = [[obj]];
			}
			// &#x884C;&#x5217;&#x306E;&#x5834;&#x5408;&#x306F;&#x4E2D;&#x8EAB;&#x3092;&#x89E3;&#x6790;&#x3057;&#x3066;&#x3044;&#x304F;
			else if(obj instanceof Array) {
				matrix_array = [];
				for(let row_count = 0; row_count &lt; obj.length; row_count++) {
					// &#x6BCE;&#x884C;&#x3054;&#x3068;&#x8ABF;&#x67FB;
					const row = obj[row_count];
					// &#x5404;&#x884C;&#x306E;&#x8981;&#x7D20;&#x304C;&#x914D;&#x5217;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x914D;&#x5217;&#x5185;&#x914D;&#x5217;&#x306E;&#x305F;&#x3081;&#x518D;&#x5EA6;for&#x6587;&#x3067;&#x8ABF;&#x3079;&#x3066;&#x3044;&#x304F;
					if(row instanceof Array) {
						const rows_array = new Array(row.length);
						// 1&#x884C;&#x3092;&#x8ABF;&#x67FB;&#x3059;&#x308B;
						for(let col_count = 0; col_count &lt; row.length; col_count++) {
							const column = row[col_count];
							// 1&#x8981;&#x7D20;&#x304C;&#x8907;&#x7D20;&#x6570;&#x306A;&#x3089;&#x305D;&#x306E;&#x307E;&#x307E;&#x4EE3;&#x5165;
							if(instanceofComplex(column)) {
								rows_array[col_count] = column;
							}
							// 1&#x8981;&#x7D20;&#x304C;&#x884C;&#x5217;&#x306A;&#x3089;&#x3001;&#x4E2D;&#x8EAB;&#x3092;&#x62BD;&#x51FA;&#x3057;&#x3066;&#x4EE3;&#x5165;
							else if(instanceofMatrix(column)) {
								if(!column.isScalar()) {
									throw &quot;Matrix in matrix&quot;;
								}
								rows_array[col_count] = column.scalar();
							}
							// &#x305D;&#x308C;&#x4EE5;&#x5916;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x8907;&#x7D20;&#x6570;&#x30AF;&#x30E9;&#x30B9;&#x306E;&#x30B3;&#x30F3;&#x30B9;&#x30C8;&#x30E9;&#x30AF;&#x30BF;&#x306B;&#x5224;&#x65AD;&#x3055;&#x305B;&#x308B;
							else {
								rows_array[col_count] = new Complex(column);
							}
						}
						matrix_array[row_count] = rows_array;
					}
					// 1&#x3064;&#x306E;&#x5024;&#x306E;&#x307F;&#x5BA3;&#x8A00;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x4E2D;&#x306E;&#x914D;&#x5217;&#x3092;&#x884C;&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x3068;&#x3057;&#x3066;&#x5B9A;&#x7FA9;&#x3059;&#x308B;
					else {
						// &#x884C;&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x306E;&#x521D;&#x671F;&#x5316;
						if(row_count === 0) {
							matrix_array[0] = new Array(obj.length);
						}
						// 1&#x8981;&#x7D20;&#x304C;&#x8907;&#x7D20;&#x6570;&#x306A;&#x3089;&#x305D;&#x306E;&#x307E;&#x307E;&#x4EE3;&#x5165;
						if(instanceofComplex(row)) {
							matrix_array[0][row_count] = row;
						}
						// 1&#x8981;&#x7D20;&#x304C;&#x884C;&#x5217;&#x306A;&#x3089;&#x3001;&#x4E2D;&#x8EAB;&#x3092;&#x62BD;&#x51FA;&#x3057;&#x3066;&#x4EE3;&#x5165;
						else if(instanceofMatrix(row)) {
							if(!row.isScalar()) {
								throw &quot;Matrix in matrix&quot;;
							}
							matrix_array[0][row_count] = row.scalar();
						}
						// &#x305D;&#x308C;&#x4EE5;&#x5916;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x8907;&#x7D20;&#x6570;&#x30AF;&#x30E9;&#x30B9;&#x306E;&#x30B3;&#x30F3;&#x30B9;&#x30C8;&#x30E9;&#x30AF;&#x30BF;&#x306B;&#x5224;&#x65AD;&#x3055;&#x305B;&#x308B;
						else {
							matrix_array[0][row_count] = new Complex(row);
						}
					}
				}
			}
			// &#x6587;&#x5B57;&#x5217;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x6587;&#x5B57;&#x5217;&#x89E3;&#x6790;&#x3092;&#x884C;&#x3046;
			else if(typeof obj === &quot;string&quot;) {
				is_check_string = true;
				matrix_array = MatrixTool.toMatrixArrayFromString(obj);
			}
			// &#x6587;&#x5B57;&#x5217;&#x5909;&#x63DB;&#x3067;&#x304D;&#x308B;&#x5834;&#x5408;&#x306F;&#x8FD4;&#x9084;&#x5F8C;&#x306B;&#x3001;&#x6587;&#x5B57;&#x5217;&#x89E3;&#x6790;&#x3092;&#x884C;&#x3046;
			else if(obj instanceof Object) {
				is_check_string = true;
				matrix_array = MatrixTool.toMatrixArrayFromString(obj.toString());
			}
			// &#x5358;&#x7D14;&#x306A;&#x30D3;&#x30EB;&#x30C8;&#x30A4;&#x30F3;&#x306E;&#x6570;&#x5024;&#x306A;&#x3069;
			else {
				matrix_array = [[new Complex(obj)]];
			}
		}
		else {
			throw &quot;Matrix : Many arguments [&quot; + arguments.length + &quot;]&quot;;
		}
		if(is_check_string) {
			// &#x6587;&#x5B57;&#x5217;&#x30C7;&#x30FC;&#x30BF;&#x306E;&#x89E3;&#x6790;&#x306E;&#x5834;&#x5408;&#x3001;&quot;:&quot; &#x30C7;&#x30FC;&#x30BF;&#x304C;&#x7D1B;&#x308C;&#x3066;&#x3044;&#x306A;&#x3044;&#x304B;&#x3092;&#x78BA;&#x8A8D;&#x3059;&#x308B;&#x3002;
			// &#x7D1B;&#x308C;&#x3066;&#x3044;&#x305F;&#x3089;&#x305D;&#x306E;&#x884C;&#x306F;&#x524A;&#x9664;&#x3059;&#x308B;&#x3002;
			for(let row = 0; row &lt; matrix_array.length; row++) {
				if(matrix_array[row] === &quot;:&quot;) {
					matrix_array.splice(row--, 1);
				}
			}
		}
		if(!MatrixTool.isCorrectMatrixArray(matrix_array)) {
			console.log(matrix_array);
			throw &quot;new Matrix IllegalArgumentException&quot;;
		}
		
		/**
		 * An array of elements in the matrix.
		 * @ignore
		 * @type {Array&lt;Array&lt;Complex&gt;&gt;}
		 */
		this.matrix_array = matrix_array;

		/**
		 * The number of rows in a matrix.
		 * @ignore
		 * @type {number}
		 */
		this.row_length = this.matrix_array.length;
		
		/**
		 * The number of columns in a matrix.
		 * @ignore
		 * @type {number}
		 */
		this.column_length = this.matrix_array[0].length;

		/**
		 * A cache that records data converted to a string.
		 * @private
		 * @ignore
		 * @type {string}
		 */
		this.string_cash = null;
	}

	/**
	 * Create an entity object of this class.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix}
	 */
	static create(number) {
		if((arguments.length === 1) &amp;&amp; (instanceofMatrix(number))) {
			return number;
		}
		else {
			return new Matrix(number);
		}
	}
	
	/**
	 * Convert number to Matrix type.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix}
	 */
	static valueOf(number) {
		return Matrix.create(number);
	}

	/**
	 * Convert to Matrix.
	 * If type conversion is unnecessary, return the value as it is.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix}
	 * @ignore
	 */
	static _toMatrix(number) {
		if(instanceofMatrix(number)) {
			return number;
		}
		else {
			return new Matrix(number);
		}
	}

	/**
	 * Convert to Complex.
	 * If type conversion is unnecessary, return the value as it is.
	 * @param {KMatrixInputData} number 
	 * @returns {Complex}
	 * @ignore
	 */
	static _toComplex(number) {
		if(instanceofComplex(number)) {
			return number;
		}
		const M = Matrix._toMatrix(number);
		if(M.isScalar()) {
			return M.scalar();
		}
		else {
			throw &quot;not scalar. [&quot; + number + &quot;]&quot;;
		}
	}

	/**
	 * Convert to real number.
	 * @param {KMatrixInputData} number 
	 * @returns {number}
	 * @ignore
	 */
	static _toDouble(number) {
		if(typeof number === &quot;number&quot;) {
			return number;
		}
		const x = Matrix._toComplex(number);
		if(x.isReal()) {
			return x.real();
		}
		else {
			throw &quot;not support complex numbers.&quot;;
		}
	}

	/**
	 * Convert to integer.
	 * @param {KMatrixInputData} number 
	 * @returns {number}
	 * @ignore
	 */
	static _toInteger(number) {
		return Math.trunc(Matrix._toDouble(number));
	}

	/**
	 * Delete cache.
	 */
	_clearCash() {
		if(this.string_cash) {
			delete this.string_cash;
		}
	}

	/**
	 * Deep copy.
	 * @returns {Matrix}
	 */
	clone() {
		return new Matrix(this.matrix_array);
	}

	/**
	 * Convert to string.
	 * @returns {string} 
	 */
	toString() {
		if(this.string_cash) {
			return this.string_cash;
		}
		if(this.isScalar()) {
			return this.scalar().toString();
		}
		const exp_turn_point = 9;
		const exp_turn_num = Math.pow(10, exp_turn_point);
		const exp_point = 4;
		let isDrawImag = false;
		let isDrawExp = false;
		let draw_decimal_position = 0;

		// &#x884C;&#x5217;&#x3092;&#x78BA;&#x8A8D;&#x3057;&#x3066;&#x8868;&#x793A;&#x3059;&#x308B;&#x305F;&#x3081;&#x306E;&#x8868;&#x793A;&#x65B9;&#x6CD5;&#x306E;&#x78BA;&#x8A8D;&#x3059;&#x308B;
		this._each(
			function(num, row, col) {
				if(!num.isReal()) {
					isDrawImag = true;
				}
				if(Number.isFinite(num.real())) {
					if(Math.abs(num.real()) &gt;= exp_turn_num) {
						isDrawExp = true;
					}
				}
				if(Number.isFinite(num.imag())) {
					if(Math.abs(num.imag()) &gt;= exp_turn_num) {
						isDrawExp = true;
					}
				}
				draw_decimal_position = Math.max(draw_decimal_position, num.getDecimalPosition());
			}
		);

		if(draw_decimal_position &gt; 0) {
			draw_decimal_position = exp_point;
		}

		// &#x6587;&#x5B57;&#x5217;&#x30C7;&#x30FC;&#x30BF;&#x3092;&#x4F5C;&#x6210;&#x3068;&#x3068;&#x3082;&#x306B;&#x3001;&#x6700;&#x5927;&#x306E;&#x9577;&#x3055;&#x3092;&#x8A18;&#x9332;&#x3059;&#x308B;
		let str_max = 0;

		/**
		 * @type {Array&lt;{re_sign : string, re_str : string, im_sign : string, im_str : string}&gt;}
		 */
		const draw_buff = [];

		// &#x6570;&#x5024;&#x30C7;&#x30FC;&#x30BF;&#x3092;&#x6587;&#x5B57;&#x5217;&#x306B;&#x3059;&#x308B;&#x95A2;&#x6570;&#xFF08;e&#x306E;&#x6841;&#x304C;&#x3042;&#x308B;&#x5834;&#x5408;&#x306F;&#x4E2D;&#x8EAB;&#x306F;3&#x6841;&#x306B;&#x3059;&#x308B;&#xFF09;
		/**
		 * @type {function(number): string }
		 */
		const toStrFromFloat = function(number) {
			const str = !isDrawExp ? number.toFixed(draw_decimal_position) : number.toExponential(exp_point);
			if(/inf/i.test(str)) {
				if(number === Number.POSITIVE_INFINITY) {
					return &quot;Inf&quot;;
				}
				else {
					return &quot;-Inf&quot;;
				}
			}
			else if(/nan/i.test(str)) {
				return &quot;NaN&quot;;
			}
			else if(!isDrawExp) {
				return str;
			}
			const split = str.split(&quot;e&quot;);
			let exp_text = split[1];
			if(exp_text.length === 2) {
				exp_text = exp_text.substr(0, 1) + &quot;00&quot; + exp_text.substr(1);
			}
			else if(exp_text.length === 3) {
				exp_text = exp_text.substr(0, 1) + &quot;0&quot; + exp_text.substr(1);
			}
			return split[0] + &quot;e&quot; + exp_text;
		};
		this._each(
			function(num) {
				const data = {};
				let real = num.real();
				data.re_sign = real &lt; 0 ? &quot;-&quot; : &quot; &quot;;
				real = Math.abs(real);
				data.re_str = toStrFromFloat(real);
				str_max = Math.max(str_max, data.re_str.length + 1);
				if(isDrawImag) {
					let imag = num.imag();
					data.im_sign = imag &lt; 0 ? &quot;-&quot; : &quot;+&quot;;
					imag = Math.abs(imag);
					data.im_str = toStrFromFloat(imag);
					str_max = Math.max(str_max, data.im_str.length + 1);
				}
				draw_buff.push(data);
			}
		);

		// &#x53F3;&#x5BC4;&#x305B;&#x7528;&#x95A2;&#x6570;
		/**
		 * @type {function(string, number): string }
		 */
		const right = function(text, length) {
			const space = &quot;                                        &quot;;
			return space.substr(0, length - text.length) + text;
		};

		// &#x51FA;&#x529B;&#x7528;&#x6587;&#x5B57;&#x5217;&#x3092;&#x4F5C;&#x6210;&#x3059;&#x308B;
		/**
		 * @type {Array&lt;string&gt;}
		 */
		const output = [];
		const that = this;
		this._each(
			function(num, row, col) {
				const data = draw_buff.shift();
				let text = right(data.re_sign + data.re_str, str_max);
				if(isDrawImag) {
					text += &quot; &quot; + data.im_sign + right(data.im_str, str_max) + &quot;i&quot;;
				}
				output.push(text);
				output.push((col &lt; that.column_length - 1) ? &quot; &quot; : &quot;\n&quot;);
			}
		);

		this.string_cash = output.join(&quot;&quot;);

		return this.string_cash;
	}

	/**
	 * Convert to string in one line.
	 * @returns {string} 
	 */
	toOneLineString() {
		if(this.isScalar()) {
			return this.scalar().toString();
		}
		let output = &quot;[ &quot;;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; this.column_length; col++) {
				output += this.matrix_array[row][col].toString();
				if(col &lt; this.column_length - 1) {
					output += &quot;, &quot;;
				}
				else {
					if(row &lt; this.row_length - 1) {
						output += &quot;; &quot;;
					}
				}
			}
		}
		output += &quot; ]&quot;;
		return output;
	}

	/**
	 * Convert to JSON.
	 * @returns {string} 
	 */
	toJSON() {
		if(this.isScalar()) {
			return this.scalar().toJSON();
		}
		let output = &quot;[&quot;;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; this.column_length; col++) {
				output += this.matrix_array[row][col].toJSON();
				if(col &lt; this.column_length - 1) {
					output += &quot;,&quot;;
				}
				else {
					if(row &lt; this.row_length - 1) {
						output += &quot;;&quot;;
					}
				}
			}
		}
		output += &quot;]&quot;;
		return output;
	}

	/**
	 * Equals.
	 * @param {KMatrixInputData} number
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean} A === B
	 */
	equals(number, tolerance) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if((M1.row_length !== M2.row_length) || (M1.column_length !== M2.column_length)) {
			return false;
		}
		if((M1.row_length === 1) &amp;&amp; (M1.column_length ===1)) {
			return M1.scalar().equals(M2.scalar(), tolerance);
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; this.column_length; col++) {
				if(!x1[row][col].equals(x2[row][col], tolerance)) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Array of real parts of elements in matrix.
	 * @returns {Array&lt;Array&lt;number&gt;&gt;}
	 */
	getNumberMatrixArray() {
		const y = new Array(this.row_length);
		for(let i = 0; i &lt; this.row_length; i++) {
			y[i] = new Array(this.column_length);
			for(let j = 0; j &lt; this.column_length; j++) {
				y[i][j] = this.matrix_array[i][j].real();
			}
		}
		return y;
	}
	
	/**
	 * Complex array of complex numbers of each element of the matrix.
	 * @returns {Array&lt;Array&lt;Complex&gt;&gt;}
	 */
	getComplexMatrixArray() {
		const y = new Array(this.row_length);
		for(let i = 0; i &lt; this.row_length; i++) {
			y[i] = new Array(this.column_length);
			for(let j = 0; j &lt; this.column_length; j++) {
				y[i][j] = this.matrix_array[i][j];
			}
		}
		return y;
	}
	
	/**
	 * Perform the same process on all elements in the matrix. (mutable)
	 * @param {function(Complex, number, number): any } eachfunc - Function(num, row, col)
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @ignore
	 */
	_each(eachfunc) {
		let isclearcash = false;
		// &#x884C;&#x512A;&#x5148;&#x3067;&#x3059;&#x3079;&#x3066;&#x306E;&#x5024;&#x306B;&#x5BFE;&#x3057;&#x3066;&#x6307;&#x5B9A;&#x3057;&#x305F;&#x95A2;&#x6570;&#x3092;&#x5B9F;&#x884C;&#x3059;&#x308B;&#x3002;&#x5185;&#x5BB9;&#x3092;&#x66F8;&#x304D;&#x63DB;&#x3048;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x3082;&#x3042;&#x308B;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; this.column_length; col++) {
				const ret = eachfunc(this.matrix_array[row][col], row, col);
				if(ret === undefined) {
					continue;
				}
				else if(instanceofComplex(ret)) {
					this.matrix_array[row][col] = ret;
				}
				else if(instanceofMatrix(ret)) {
					this.matrix_array[row][col] = ret.scalar();
				}
				else {
					this.matrix_array[row][col] = new Complex(ret);
				}
				isclearcash = true;
			}
		}
		if(isclearcash) {
			this._clearCash();
		}
		return this;
	}

	/**
	 * Perform the same process on all elements in the matrix.
	 * @param {function(Complex, number, number): ?Object } eachfunc - Function(num, row, col)
	 * @returns {Matrix} Matrix after function processing.
	 */
	cloneMatrixDoEachCalculation(eachfunc) {
		return this.clone()._each(eachfunc);
	}

	/**
	 * Create Matrix with specified initialization for each element in matrix.
	 * @param {function(number, number): ?Object } eachfunc - Function(row, col)
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length=dimension] - Number of columns.
	 * @returns {Matrix} Matrix after function processing.
	 */
	static createMatrixDoEachCalculation(eachfunc, dimension, column_length) {
		if((arguments.length === 0) || (arguments.length &gt; 3)) {
			throw &quot;IllegalArgumentException&quot;;
		}
		const y_row_length = Matrix._toInteger(dimension);
		const y_column_length = column_length ? Matrix._toInteger(column_length) : y_row_length;
		const y = new Array(y_row_length);
		for(let row = 0; row &lt; y_row_length; row++) {
			y[row] = new Array(y_column_length);
			for(let col = 0; col &lt; y_column_length; col++) {
				const ret = eachfunc(row, col);
				if(ret === undefined) {
					y[row][col] = Complex.ZERO;
				}
				else {
					y[row][col] = Matrix._toComplex(ret);
				}
			}
		}
		return new Matrix(y);
	}

	/**
	 * Treat the columns of the matrix as vectors and execute the same process.
	 * - If the matrix is a row vector, it performs the same processing for the row vector.
	 * @param {function(Array&lt;Complex&gt;): Array&lt;Complex&gt;} array_function - Function(array)
	 * @returns {Matrix} Matrix after function processing.
	 */
	eachVectorAuto(array_function) {
		if(this.isRow()) {
			// 1&#x884C;&#x3067;&#x3042;&#x308C;&#x3070;&#x3001;&#x305D;&#x306E;1&#x884C;&#x306B;&#x5BFE;&#x3057;&#x3066;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
			const row_array = new Array(this.row_length);
			for(let col = 0; col &lt; this.column_length; col++) {
				row_array[col] = this.matrix_array[0][col];
			}
			return new Matrix(array_function(row_array));
		}
		else {
			const y = Matrix.ZERO.clone();
			y._resize(1, this.column_length);
			// 1&#x5217;&#x3001;&#x884C;&#x5217;&#x3067;&#x3042;&#x308C;&#x3070;&#x3001;&#x5217;&#x3054;&#x3068;&#x306B;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
			for(let col = 0; col &lt; this.column_length; col++) {
				const col_array = new Array(this.row_length);
				for(let row = 0; row &lt; this.row_length; row++) {
					col_array[row] = this.matrix_array[row][col];
				}
				const col_output = array_function(col_array);
				y._resize(Math.max(y.row_length, col_output.length), y.column_length);
				for(let row = 0; row &lt; col_output.length; row++) {
					y.matrix_array[row][col] = col_output[row];
				}
			}
			return y;
		}
	}

	/**
	 * Treat the rows and columns of the matrix as vectors and perform the same processing.
	 * 1. First run the same process for the row.
	 * 2. Finally perform the same processing for the column.
	 * @param {function(Array&lt;Complex&gt;): Array&lt;Complex&gt;} array_function - Function(array)
	 * @returns {Matrix} Matrix after function processing.
	 */
	eachVectorBoth(array_function) {
		const y1 = Matrix.ZERO.clone();
		// &#x884C;&#x3054;&#x3068;&#x306B;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
		y1._resize(this.row_length, 1);
		for(let row = 0; row &lt; this.row_length; row++) {
			const row_array = new Array(this.column_length);
			for(let col = 0; col &lt; this.column_length; col++) {
				row_array[col] = this.matrix_array[row][col];
			}
			const row_output = array_function(row_array);
			y1._resize(y1.row_length, Math.max(y1.column_length, row_output.length));
			for(let col = 0; col &lt; row_output.length; col++) {
				y1.matrix_array[row][col] = row_output[col];
			}
		}
		const y2 = Matrix.ZERO.clone();
		// &#x5217;&#x3054;&#x3068;&#x306B;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
		y2._resize(1, y1.column_length);
		for(let col = 0; col &lt; y1.column_length; col++) {
			const col_array = new Array(y1.row_length);
			for(let row = 0; row &lt; y1.row_length; row++) {
				col_array[row] = y1.matrix_array[row][col];
			}
			const col_output = array_function(col_array);
			y2._resize(Math.max(y2.row_length, col_output.length), y2.column_length);
			for(let row = 0; row &lt; col_output.length; row++) {
				y2.matrix_array[row][col] = col_output[row];
			}
		}
		return y2;
	}

	/**
	 * Treat the rows of the matrix as vectors and execute the same process.
	 * @param {function(Array&lt;Complex&gt;): Array&lt;Complex&gt;} array_function - Function(array)
	 * @returns {Matrix} Matrix after function processing.
	 */
	eachVectorRow(array_function) {
		const y = Matrix.ZERO.clone();
		// &#x884C;&#x3054;&#x3068;&#x306B;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
		y._resize(this.row_length, 1);
		for(let row = 0; row &lt; this.row_length; row++) {
			const row_array = new Array(this.column_length);
			for(let col = 0; col &lt; this.column_length; col++) {
				row_array[col] = this.matrix_array[row][col];
			}
			const row_output = array_function(row_array);
			y._resize(y.row_length, Math.max(y.column_length, row_output.length));
			for(let col = 0; col &lt; row_output.length; col++) {
				y.matrix_array[row][col] = row_output[col];
			}
		}
		return y;
	}

	/**
	 * Treat the columns of the matrix as vectors and execute the same process.
	 * @param {function(Array&lt;Complex&gt;): Array&lt;Complex&gt;} array_function - Function(array)
	 * @returns {Matrix} Matrix after function processing.
	 */
	eachVectorColumn(array_function) {
		const y = Matrix.ZERO.clone();
		// &#x5217;&#x3054;&#x3068;&#x306B;&#x51E6;&#x7406;&#x3092;&#x884C;&#x3046;
		y._resize(1, this.column_length);
		for(let col = 0; col &lt; this.column_length; col++) {
			const col_array = new Array(this.row_length);
			for(let row = 0; row &lt; this.row_length; row++) {
				col_array[row] = this.matrix_array[row][col];
			}
			const col_output = array_function(col_array);
			y._resize(Math.max(y.row_length, col_output.length), y.column_length);
			for(let row = 0; row &lt; col_output.length; row++) {
				y.matrix_array[row][col] = col_output[row];
			}
		}
		return y;
	}

	/**
	 * Treat the rows and columns of the matrix as vectors and perform the same processing.
	 * The arguments of the method can switch the direction of the matrix to be executed.
	 * @param {function(Array&lt;Complex&gt;): Array&lt;Complex&gt;} array_function - Function(array)
	 * @param {string|number} [dimension=&quot;auto&quot;] - 0/&quot;auto&quot;, 1/&quot;row&quot;, 2/&quot;column&quot;, 3/&quot;both&quot;
	 * @returns {Matrix} Matrix after function processing.
	 */
	eachVector(array_function, dimension) {
		let target = dimension !== undefined ? dimension : &quot;auto&quot;;
		if(typeof target === &quot;string&quot;) {
			target = target.toLocaleLowerCase();
		}
		else if(typeof target !== &quot;number&quot;) {
			target = Matrix._toInteger(target);
		}
		if((target === &quot;auto&quot;) || (target === 0)) {
			return this.eachVectorAuto(array_function);
		}
		else if((target === &quot;row&quot;) || (target === 1)) {
			return this.eachVectorRow(array_function);
		}
		else if((target === &quot;column&quot;) || (target === 2)) {
			return this.eachVectorColumn(array_function);
		}
		else if((target === &quot;both&quot;) || (target === 3)) {
			return this.eachVectorBoth(array_function);
		}
		else {
			throw &quot;eachVector argument &quot; + dimension;
		}
	}

	/**
	 * Extract the specified part of the matrix.
	 * @param {KMatrixInputData} row - A vector containing the row numbers to extract from this matrix. If you specify &quot;:&quot; select all rows.
	 * @param {KMatrixInputData} col - A vector containing the column numbers to extract from this matrix. If you specify &quot;:&quot; select all columns.
	 * @param {boolean} [isUpOffset=false] - Set offset of matrix position to 1 with true.
	 * @returns {Matrix} 
	 */
	getMatrix(row, col, isUpOffset=false) {
		const geta = isUpOffset ? 1 : 0 ;
		const row_array = MatrixTool.toPositionArrayFromObject(row, this.row_length, geta);
		const col_array = MatrixTool.toPositionArrayFromObject(col, this.column_length, geta);
		const x = this.matrix_array;
		const y = new Array(row_array.length);
		for(let row = 0; row &lt; row_array.length; row++) {
			const y_row = new Array(col_array.length);
			for(let col = 0; col &lt; col_array.length; col++) {
				y_row[col] = x[row_array[row] - geta][col_array[col] - geta];
			}
			y[row] = y_row;
		}
		return new Matrix(y);
	}

	/**
	 * Change specified element in matrix.
	 * @param {KMatrixInputData} row - A vector containing the row numbers to replace in this matrix. If you specify &quot;:&quot; select all rows.
	 * @param {KMatrixInputData} col - A vector containing the column numbers to replace in this matrix. If you specify &quot;:&quot; select all columns.
	 * @param {KMatrixInputData} replace - Matrix to be replaced.
	 * @param {boolean} [isUpOffset=false] - Set offset of matrix position to 1 with true.
	 * @returns {Matrix} 
	 */
	setMatrix(row, col, replace, isUpOffset=false) {
		const geta = isUpOffset ? 1 : 0 ;
		const row_array = MatrixTool.toPositionArrayFromObject(row, this.row_length, geta);
		const col_array = MatrixTool.toPositionArrayFromObject(col, this.column_length, geta);
		const Y = new Matrix(this);
		const y = Y.matrix_array;
		const X = Matrix._toMatrix(replace);
		const x = X.matrix_array;
		for(let row = 0; row &lt; row_array.length; row++) {
			for(let col = 0; col &lt; col_array.length; col++) {
				y[row_array[row] - geta][col_array[col] - geta] = x[row % X.row_length][col % X.column_length];
			}
		}
		return new Matrix(y);
	}

	/**
	 * Returns the specified element in the matrix.
	 * Each element of the matrix is composed of complex numbers.
	 * @param {KMatrixInputData} row_or_pos - If this is a matrix, the row number. If this is a vector, the address.
	 * @param {KMatrixInputData} [col] - If this is a matrix, the column number.
	 * @returns {Complex} 
	 */
	getComplex(row_or_pos, col) {
		let row_or_pos_scalar = null;
		let col_scalar = null;
		if(arguments.length === 1) {
			row_or_pos_scalar = Matrix._toInteger(row_or_pos);
		}
		else if(arguments.length === 2) {
			row_or_pos_scalar = Matrix._toInteger(row_or_pos);
			col_scalar = Matrix._toInteger(col);
		}
		if(this.isRow()) {
			return this.matrix_array[0][row_or_pos_scalar];
		}
		else if(this.isColumn()) {
			return this.matrix_array[row_or_pos_scalar][0];
		}
		else {
			return this.matrix_array[row_or_pos_scalar][col_scalar];
		}
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x4ED6;&#x306E;&#x578B;&#x306B;&#x5909;&#x63DB;&#x7528;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	
	/**
	 * Boolean value of the first element of the matrix.
	 * @returns {boolean}
	 */
	booleanValue() {
		return this.matrix_array[0][0].booleanValue();
	}

	/**
	 * Integer value of the first element of the matrix.
	 * @returns {number}
	 */
	intValue() {
		return this.matrix_array[0][0].intValue();
	}

	/**
	 * Real value of first element of the matrix.
	 * @returns {number}
	 */
	doubleValue() {
		return this.matrix_array[0][0].doubleValue();
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// konpeito &#x3067;&#x6271;&#x3046;&#x6570;&#x5024;&#x578B;&#x3078;&#x5909;&#x63DB;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * return Complex.
	 * @returns {Complex}
	 */
	toComplex() {
		return this.scalar();
	}
	
	/**
	 * return Matrix.
	 * @returns {Matrix}
	 */
	toMatrix() {
		return this;
	}
	
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x884C;&#x5217;&#x306E;&#x57FA;&#x672C;&#x64CD;&#x4F5C;&#x3001;&#x57FA;&#x672C;&#x60C5;&#x5831;&#x306E;&#x53D6;&#x5F97;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	
	/**
	 * First element of this matrix.
	 * @returns {Complex}
	 */
	scalar() {
		return this.matrix_array[0][0];
	}

	/**
	 * Maximum size of rows or columns in the matrix.
	 * @returns {number}
	 */
	length() {
		return this.row_length &gt; this.column_length ? this.row_length : this.column_length;
	}

	/**
	 * Number of columns in the matrix.
	 * @returns {number}
	 */
	width() {
		return this.column_length;
	}

	/**
	 * Number of rows in matrix.
	 * @returns {number}
	 */
	height() {
		return this.row_length;
	}

	/**
	 * 1-norm.
	 * @returns {number}
	 */
	norm1() {
		return LinearAlgebra.norm(this, 1);
	}
	
	/**
	 * 2-norm.
	 * @returns {number}
	 */
	norm2() {
		return LinearAlgebra.norm(this, 2);
	}

	/**
	 * p-norm.
	 * @param {KMatrixInputData} [p=2]
	 * @returns {number}
	 */
	norm(p) {
		return LinearAlgebra.norm(this, p);
	}

	/**
	 * Condition number of the matrix
	 * @param {KMatrixInputData} [p=2]
	 * @returns {number}
	 */
	cond(p) {
		return LinearAlgebra.cond(this, p);
	}

	/**
	 * Inverse condition number.
	 * @returns {number}
	 */
	rcond() {
		return LinearAlgebra.rcond(this);
	}

	/**
	 * Rank.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {number} rank(A)
	 */
	rank(tolerance) {
		return LinearAlgebra.rank(this, tolerance);
	}

	/**
	 * Trace of a matrix.
	 * Sum of diagonal elements.
	 * @returns {Complex} trace(A)
	 */
	trace() {
		return LinearAlgebra.trace(this);
	}

	/**
	 * Determinant.
	 * @returns {Matrix} |A|
	 */
	det() {
		return LinearAlgebra.det(this);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x884C;&#x5217;&#x306E;&#x4F5C;&#x6210;&#x95A2;&#x4FC2;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	
	/**
	 * Creates a matrix composed of the specified number.
	 * @param {KMatrixInputData} number - Value after initialization.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @returns {Matrix}
	 */
	static memset(number, dimension, column_length) {
		if((arguments.length === 0) || (arguments.length &gt; 3)) {
			throw &quot;IllegalArgumentException&quot;;
		}
		const M = Matrix._toMatrix(number);
		if(!M.isScalar()) {
			const x = M.matrix_array;
			const x_row_length = M.row_length;
			const x_column_length = M.column_length;
			return Matrix.createMatrixDoEachCalculation(function(row, col) {
				return x[row % x_row_length][col % x_column_length];
			}, dimension, column_length);
		}
		else {
			const x = M.scalar();
			return Matrix.createMatrixDoEachCalculation(function() {
				return x;
			}, dimension, column_length);
		}
	}

	/**
	 * Return identity matrix.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @returns {Matrix}
	 */
	static eye(dimension, column_length) {
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return row === col ? Complex.ONE : Complex.ZERO;
		}, dimension, column_length);
	}
	
	/**
	 * Create zero matrix.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @returns {Matrix}
	 */
	static zeros(dimension, column_length) {
		if((arguments.length === 0) || (arguments.length &gt; 2)) {
			throw &quot;IllegalArgumentException&quot;;
		}
		return Matrix.memset(Complex.ZERO, dimension, column_length);
	}

	/**
	 * Create a matrix of all ones.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @returns {Matrix}
	 */
	static ones(dimension, column_length) {
		if((arguments.length === 0) || (arguments.length &gt; 2)) {
			throw &quot;IllegalArgumentException&quot;;
		}
		return Matrix.memset(Complex.ONE, dimension, column_length);
	}

	/**
	 * If matrix, generate diagonal column vector.
	 * If vector, generate a matrix with diagonal elements.
	 * @returns {Matrix} Matrix or vector created. See how to use the function.
	 */
	diag() {
		if(this.isVector()) {
			// &#x884C;&#x5217;&#x3092;&#x4F5C;&#x6210;
			const M = this;
			return Matrix.createMatrixDoEachCalculation(function(row, col) {
				if(row === col) {
					return M.getComplex(row);
				}
				else {
					return Complex.ZERO;
				}
			}, this.length());
		}
		else {
			// &#x5217;&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x3092;&#x4F5C;&#x6210;
			const len = Math.min(this.row_length, this.column_length);
			const y = new Array(len);
			for(let i = 0; i &lt; len; i++) {
				y[i] = new Array(1);
				y[i][0] = this.matrix_array[i][i];
			}
			return new Matrix(y);
		}
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x6BD4;&#x8F03;&#x3084;&#x5224;&#x5B9A;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Return true if the matrix is scalar.
	 * @returns {boolean}
	 */
	isScalar() {
		return this.row_length === 1 &amp;&amp; this.column_length == 1;
	}
	
	/**
	 * Return true if the matrix is row vector.
	 * @returns {boolean}
	 */
	isRow() {
		return this.row_length === 1;
	}
	
	/**
	 * Return true if the matrix is column vector.
	 * @returns {boolean}
	 */
	isColumn() {
		return this.column_length === 1;
	}

	/**
	 * Return true if the matrix is vector.
	 * @returns {boolean}
	 */
	isVector() {
		return this.row_length === 1 || this.column_length === 1;
	}

	/**
	 * Return true if the value is not scalar.
	 * @returns {boolean}
	 */
	isMatrix() {
		return this.row_length !== 1 &amp;&amp; this.column_length !== 1;
	}

	/**
	 * Return true if the matrix is square matrix.
	 * @returns {boolean}
	 */
	isSquare() {
		return this.row_length === this.column_length;
	}

	/**
	 * Return true if the matrix is real matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isReal(tolerance) {
		let is_real = true;
		this._each(function(num){
			if(is_real &amp;&amp; (num.isComplex(tolerance))) {
				is_real = false;
			}
		});
		return is_real;
	}

	/**
	 * Return true if the matrix is complex matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isComplex(tolerance) {
		return !this.isReal(tolerance);
	}

	/**
	 * Return true if the matrix is zero matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isZeros(tolerance) {
		let is_zeros = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num){
			if(is_zeros &amp;&amp; (!num.isZero(tolerance_))) {
				is_zeros = false;
			}
		});
		return is_zeros;
	}

	/**
	 * Return true if the matrix is identity matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isIdentity(tolerance) {
		let is_identity = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num, row, col){
			if(is_identity) {
				if(row === col) {
					if(!num.isOne(tolerance_)) {
						is_identity = false;
					}
				}
				else {
					if(!num.isZero(tolerance_)) {
						is_identity = false;
					}
				}
			}
		});
		return is_identity;
	}

	/**
	 * Return true if the matrix is diagonal matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isDiagonal(tolerance) {
		let is_diagonal = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num, row, col){
			if(is_diagonal &amp;&amp; (row !== col) &amp;&amp; (!num.isZero(tolerance_))) {
				is_diagonal = false;
			}
		});
		return is_diagonal;
	}
	
	/**
	 * Return true if the matrix is tridiagonal matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isTridiagonal(tolerance) {
		let is_tridiagonal = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num, row, col){
			if(is_tridiagonal &amp;&amp; (Math.abs(row - col) &gt; 1) &amp;&amp; (!num.isZero(tolerance_))) {
				is_tridiagonal = false;
			}
		});
		return is_tridiagonal;
	}

	/**
	 * Return true if the matrix is regular matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isRegular(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		// &#x30E9;&#x30F3;&#x30AF;&#x304C;&#x884C;&#x5217;&#x306E;&#x6B21;&#x5143;&#x3068;&#x7B49;&#x3057;&#x3044;&#x304B;&#x3069;&#x3046;&#x304B;&#x3067;&#x5224;&#x5B9A;
		// det(M) != 0 &#x3067;&#x3082;&#x3088;&#x3044;&#x304C;&#x3001;&#x6642;&#x9593;&#x304C;&#x304B;&#x304B;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x306E;&#x3067;
		// &#x8AA4;&#x5DEE;&#x306F;&#x81EA;&#x52D5;&#x3067;&#x8A08;&#x7B97;&#x306A;&#x3069;&#x672C;&#x5F53;&#x306F;&#x3082;&#x3046;&#x3059;&#x3053;&#x3057;&#x826F;&#x3044;&#x65B9;&#x6CD5;&#x3092;&#x8003;&#x3048;&#x308B;&#x5FC5;&#x8981;&#x304C;&#x3042;&#x308B;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		return (this.rank(tolerance_) === this.row_length);
	}

	/**
	 * Return true if the matrix is orthogonal matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isOrthogonal(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		return (this.mul(this.transpose()).isIdentity(tolerance_));
	}

	/**
	 * Return true if the matrix is unitary matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isUnitary(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		return (this.mul(this.ctranspose()).isIdentity(tolerance_));
	}

	/**
	 * Return true if the matrix is symmetric matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isSymmetric(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = row + 1; col &lt; this.column_length; col++) {
				if(!this.matrix_array[row][col].equals(this.matrix_array[col][row], tolerance_)) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Return true if the matrix is hermitian matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isHermitian(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = row; col &lt; this.column_length; col++) {
				if(row === col) {
					if(!this.matrix_array[row][col].isReal(tolerance_)) {
						return false;
					}
				}
				else if(!this.matrix_array[row][col].equals(this.matrix_array[col][row].conj(), tolerance_)) {
					return false;
				}
			}
		}
		return true;
	}
	
	/**
	 * Return true if the matrix is upper triangular matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isTriangleUpper(tolerance) {
		let is_upper = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num, row, col){
			if(is_upper &amp;&amp; (row &gt; col) &amp;&amp; (!num.isZero(tolerance_))) {
				is_upper = false;
			}
		});
		return is_upper;
	}

	/**
	 * Return true if the matrix is  lower triangular matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isTriangleLower(tolerance) {
		let is_lower = true;
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		this._each(function(num, row, col){
			if(is_lower &amp;&amp; (row &lt; col) &amp;&amp; (!num.isZero(tolerance_))) {
				is_lower = false;
			}
		});
		return is_lower;
	}

	/**
	 * Return true if the matrix is permutation matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isPermutation(tolerance) {
		if(!this.isSquare()) {
			return false;
		}
		const tolerance_ = tolerance ? tolerance : 1.0e-10;
		const is_row = new Array(this.row_length);
		const is_col = new Array(this.column_length);
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; this.column_length; col++) {
				const target = this.matrix_array[row][col];
				if(target.isOne(tolerance_)) {
					if(!is_row[row] &amp;&amp; !is_col[col]) {
						is_row[row] = 1;
						is_col[col] = 1;
					}
					else {
						return false;
					}
				}
				else if(!target.isZero(tolerance_)) {
					return false;
				}
			}
		}
		for(let i = 0;i &lt; this.row_length; i++) {
			if(is_row[i] === undefined || is_col[i] === undefined) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Number of rows and columns of matrix.
	 * @param {?string|?number} [dimension] direction. 1/&quot;row&quot;, 2/&quot;column&quot;
	 * @returns {Matrix} [row_length, column_length]
	 */
	size(dimension) {
		if(dimension !== undefined) {
			let target = dimension;
			if(typeof target === &quot;string&quot;) {
				target = target.toLocaleLowerCase();
			}
			else if(typeof target !== &quot;number&quot;) {
				target = Matrix._toInteger(target);
			}
			if((target === &quot;row&quot;) || (target === 1)) {
				return new Matrix(this.row_length);
			}
			else if((target === &quot;column&quot;) || (target === 2)) {
				return new Matrix(this.column_length);
			}
		}
		// &#x884C;&#x5217;&#x306E;&#x30B5;&#x30A4;&#x30BA;&#x3092;&#x53D6;&#x5F97;
		return new Matrix([[this.row_length, this.column_length]]);
	}

	/**
	 * Compare values.
	 * - Use `compareToMatrix` if you want to compare matrices.
	 * @param {KMatrixInputData} number 
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {number} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareTo(number, tolerance) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		// &#x203B;&#x30B9;&#x30AB;&#x30E9;&#x30FC;&#x540C;&#x58EB;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;&#x5B9F;&#x6570;&#x3092;&#x8FD4;&#x3059;
		if(M1.isScalar() &amp;&amp; M2.isScalar()) {
			return M1.scalar().compareTo(M2.scalar(), tolerance);
		}
		throw &quot;IllegalArgumentException&quot;;
	}

	/**
	 * Compare values.
	 * - Use `compareTo` if you want to compare scalar values.
	 * @param {KMatrixInputData} number 
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareToMatrix(number, tolerance) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].compareTo(x2[row % M2.row_length][col % M2.column_length], tolerance);
		}, y_row_length, y_column_length);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x56DB;&#x5247;&#x6F14;&#x7B97;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	
	/**
	 * Add.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A + B
	 */
	add(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if((M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].add(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Subtract.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A - B
	 */
	sub(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if((M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].sub(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Multiply.
	 * - Use `dotmul` if you want to use `mul` for each element.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A * B
	 */
	mul(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		if(M1.isScalar() &amp;&amp; M2.isScalar()) {
			return new Matrix(M1.scalar().mul(M2.scalar()));
		}
		if(M1.isScalar()) {
			const y = new Array(M2.row_length);
			for(let row = 0; row &lt; M2.row_length; row++) {
				y[row] = new Array(M2.column_length);
				for(let col = 0; col &lt; M2.column_length; col++) {
					y[row][col] = M1.scalar().mul(x2[row][col]);
				}
			}
			return new Matrix(y);
		}
		else if(M2.isScalar()) {
			const y = new Array(M1.row_length);
			for(let row = 0; row &lt; M1.row_length; row++) {
				y[row] = new Array(M1.column_length);
				for(let col = 0; col &lt; M1.column_length; col++) {
					y[row][col] = x1[row][col].mul(M2.scalar());
				}
			}
			return new Matrix(y);
		}
		if(M1.column_length !== M2.row_length) {
			throw &quot;Matrix size does not match&quot;;
		}
		{
			const y = new Array(M1.row_length);
			for(let row = 0; row &lt; M1.row_length; row++) {
				y[row] = new Array(M2.column_length);
				for(let col = 0; col &lt; M2.column_length; col++) {
					let sum = Complex.ZERO;
					for(let i = 0; i &lt; M1.column_length; i++) {
						sum = sum.add(x1[row][i].mul(x2[i][col]));
					}
					y[row][col] = sum;
				}
			}
			return new Matrix(y);
		}
	}

	/**
	 * Divide.
	 * - Use `dotdiv` if you want to use `div` for each element.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A / B
	 */
	div(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		const x1 = M1.matrix_array;
		if(M1.isScalar() &amp;&amp; M2.isScalar()) {
			return new Matrix(M1.scalar().div(M2.scalar()));
		}
		if(M2.isScalar()) {
			const y = new Array(M1.row_length);
			for(let row = 0; row &lt; M1.row_length; row++) {
				y[row] = new Array(M1.column_length);
				for(let col = 0; col &lt; M1.column_length; col++) {
					y[row][col] = x1[row][col].div(M2.scalar());
				}
			}
			return new Matrix(y);
		}
		if(M2.row_length === M2.column_length) {
			const tolerance = 1.0e-10;
			const det = M2.det().scalar().norm();
			if(det &gt; tolerance) {
				// &#x30E9;&#x30F3;&#x30AF;&#x843D;&#x3061;&#x3057;&#x3066;&#x3044;&#x306A;&#x3044;&#x306E;&#x3067;&#x901A;&#x5E38;&#x306E;&#x9006;&#x884C;&#x5217;&#x3092;&#x4F7F;&#x7528;&#x3059;&#x308B;
				return this.mul(M2.inv());
			}
			else {
				// &#x30E9;&#x30F3;&#x30AF;&#x843D;&#x3061;&#x3057;&#x3066;&#x3044;&#x308B;&#x306E;&#x3067;&#x7591;&#x4F3C;&#x9006;&#x884C;&#x5217;&#x3092;&#x4F7F;&#x7528;&#x3059;&#x308B;
				return this.mul(M2.pinv());
			}
		}
		if(M1.column_length !== M2.column_length) {
			throw &quot;Matrix size does not match&quot;;
		}
		throw &quot;warning&quot;;
	}

	/**
	 * Inverse matrix of this matrix.
	 * - Use `dotinv` if you want to use `inv` for each element.
	 * @returns {Matrix} A^-1
	 */
	inv() {
		return LinearAlgebra.inv(this);
	}

	/**
	 * Multiplication for each element of matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .* B
	 */
	dotmul(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if(!M1.isScalar() &amp;&amp; !M2.isScalar() &amp;&amp; (M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].mul(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Division for each element of matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A ./ B
	 */
	dotdiv(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if(!M1.isScalar() &amp;&amp; !M2.isScalar() &amp;&amp; (M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].div(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Inverse of each element of matrix.
	 * @returns {Matrix} 1 ./ A
	 */
	dotinv() {
		const M1 = this;
		const x1 = M1.matrix_array;
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row][col].inv();
		}, M1.row_length, M1.column_length);
	}

	/**
	 * Multiplication for each element of matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .* B
	 * @deprecated use the dotmul.
	 */
	nmul(number) {
		return this.dotmul(number);
	}

	/**
	 * Division for each element of matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A ./ B
	 * @deprecated use the dotdiv.
	 */
	ndiv(number) {
		return this.dotdiv(number);
	}

	/**
	 * Inverse of each element of matrix.
	 * @returns {Matrix} 1 ./ A
	 * @deprecated use the dotinv.
	 */
	ninv() {
		return this.dotinv();
	}

	/**
	 * Power function for each element of the matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .^ B
	 * @deprecated use the dotpow.
	 */
	npow(number) {
		return this.dotpow(number);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x4F59;&#x308A;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Modulo, positive remainder of division for each element of matrix.
	 * - Result has same sign as the Dividend.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .rem B
	 */
	rem(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if(!M1.isScalar() &amp;&amp; !M2.isScalar() &amp;&amp; (M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].rem(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Modulo, positive remainder of division for each element of matrix.
	 * - Result has same sign as the Divisor.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .mod B
	 */
	mod(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if(!M1.isScalar() &amp;&amp; !M2.isScalar() &amp;&amp; (M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].mod(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}
	
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// Complex&#x306E;&#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x306B;&#x3042;&#x308B;&#x6A5F;&#x80FD;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Real part of each element.
	 * @returns {Matrix} real(A)
	 */
	real() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return new Complex(num.real());
		});
	}
	
	/**
	 * Imaginary part of each element of the matrix.
	 * @returns {Matrix} imag(A)
	 */
	imag() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return new Complex(num.imag());
		});
	}

	/**
	 * The argument of each element of matrix.
	 * @returns {Matrix} arg(A)
	 */
	arg() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return new Complex(num.arg());
		});
	}

	/**
	 * The positive or negative signs of each element of the matrix.
	 * - +1 if positive, -1 if negative, 0 if 0, norm if complex number.
	 * @returns {Matrix}
	 */
	sign() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return new Complex(num.sign());
		});
	}

	/**
	 * Floor.
	 * @returns {Matrix} floor(A)
	 */
	floor() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.floor();
		});
	}

	/**
	 * Ceil.
	 * @returns {Matrix} ceil(A)
	 */
	ceil() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.ceil();
		});
	}

	/**
	 * Rounding to the nearest integer.
	 * @returns {Matrix} round(A)
	 */
	round() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.round();
		});
	}

	/**
	 * To integer rounded down to the nearest.
	 * @returns {Matrix} fix(A), trunc(A)
	 */
	fix() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.fix();
		});
	}

	/**
	 * Fraction.
	 * @returns {Matrix} fract(A)
	 */
	fract() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.fract();
		});
	}

	/**
	 * Absolute value.
	 * @returns {Matrix} abs(A)
	 */
	abs() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.abs();
		});
	}

	/**
	 * Complex conjugate matrix.
	 * @returns {Matrix} real(A) - imag(A)j
	 */
	conj() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.conj();
		});
	}

	/**
	 * this * -1
	 * @returns {Matrix} -A
	 */
	negate() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.negate();
		});
	}

	// ----------------------
	// &#x6307;&#x6570;
	// ----------------------
	
	/**
	 * Power function.
	 * - Unless the matrix is a scalar value, only integers are supported.
	 * - Use `dotpow` if you want to use `pow` for each element. A real number can be specified.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix} pow(A, B)
	 */
	pow(number) {
		if(this.isScalar()) {
			return new Matrix(this.scalar().pow(Matrix._toDouble(number)));
		}
		else {
			if(!this.isSquare()) {
				throw &quot;not square &quot; + this;
			}
			let n = Matrix._toInteger(number);
			if(n &lt; 0) {
				throw &quot;error negative number &quot; + n;
			}
			let x, y;
			x = this.clone();
			y = Matrix.eye(this.length());
			while(n !== 0) {
				if((n &amp; 1) !== 0) {
					y = y.mul(x);
				}
				x = x.mul(x);
				n &gt;&gt;&gt;= 1;
			}
			return y;
		}
	}

	/**
	 * Power function for each element of the matrix.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A .^ B
	 */
	dotpow(number) {
		const M1 = this;
		const M2 = Matrix._toMatrix(number);
		if(!M1.isScalar() &amp;&amp; !M2.isScalar() &amp;&amp; (M1.row_length !== M2.row_length) &amp;&amp; (M1.column_length !== M2.column_length)) {
			throw &quot;Matrix size does not match&quot;;
		}
		const x1 = M1.matrix_array;
		const x2 = M2.matrix_array;
		const y_row_length = Math.max(M1.row_length, M2.row_length);
		const y_column_length = Math.max(M1.column_length, M2.column_length);
		return Matrix.createMatrixDoEachCalculation(function(row, col) {
			return x1[row % M1.row_length][col % M1.column_length].pow(x2[row % M2.row_length][col % M2.column_length]);
		}, y_row_length, y_column_length);
	}

	/**
	 * Square.
	 * - Unless the matrix is a scalar value, only integers are supported.
	 * @returns {Matrix} pow(A, 2)
	 */
	square() {
		return this.pow(2);
	}

	/**
	 * Square root.
	 * @returns {Matrix} sqrt(A)
	 */
	sqrt() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sqrt();
		});
	}

	/**
	 * Cube root.
	 * @returns {Matrix} sqrt(A)
	 */
	cbrt() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.cbrt();
		});
	}

	/**
	 * Reciprocal square root.
	 * @returns {Matrix} rsqrt(A)
	 */
	rsqrt() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.rsqrt();
		});
	}

	/**
	 * Logarithmic function.
	 * @returns {Matrix} log(A)
	 */
	log() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.log();
		});
	}

	/**
	 * Exponential function.
	 * @returns {Matrix} exp(A)
	 */
	exp() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.exp();
		});
	}

	/**
	 * e^x - 1
	 * @returns {Matrix} expm1(A)
	 */
	expm1() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.expm1();
		});
	}

	/**
	 * ln(1 + x)
	 * @returns {Matrix} log1p(A)
	 */
	log1p() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.log1p();
		});
	}
	
	/**
	 * log_2(x)
	 * @returns {Matrix} log2(A)
	 */
	log2() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.log2();
		});
	}

	/**
	 * log_10(x)
	 * @returns {Matrix} log10(A)
	 */
	log10() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.log10();
		});
	}

	// ----------------------
	// &#x4E09;&#x89D2;&#x95A2;&#x6570;
	// ----------------------
	
	/**
	 * Sine function.
	 * @returns {Matrix} sin(A)
	 */
	sin() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sin();
		});
	}

	/**
	 * Cosine function.
	 * @returns {Matrix} cos(A)
	 */
	cos() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.cos();
		});
	}

	/**
	 * Tangent function.
	 * @returns {Matrix} tan(A)
	 */
	tan() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tan();
		});
	}
	
	/**
	 * Atan (arc tangent) function.
	 * - Return the values of [-PI/2, PI/2].
	 * @returns {Matrix} atan(A)
	 */
	atan() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.atan();
		});
	}

	/**
	 * Atan (arc tangent) function.
	 * - Return the values of [-PI, PI].
	 * - Supports only real numbers.
	 * @param {KMatrixInputData} number - X
	 * @returns {Matrix} atan2(Y, X)
	 */
	atan2(number) {
		const X = Matrix._toComplex(number);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.atan2(X);
		});
	}

	// ----------------------
	// &#x53CC;&#x66F2;&#x7DDA;&#x95A2;&#x6570;
	// ----------------------
	
	/**
	 * Arc sine function.
	 * @returns {Matrix} asin(A)
	 */
	asin() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.asin();
		});
	}

	/**
	 * Arc cosine function.
	 * @returns {Matrix} acos(A)
	 */
	acos() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acos();
		});
	}
	
	/**
	 * Hyperbolic sine function.
	 * @returns {Matrix} sinh(A)
	 */
	sinh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sinh();
		});
	}

	/**
	 * Inverse hyperbolic sine function.
	 * @returns {Matrix} asinh(A)
	 */
	asinh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.asinh();
		});
	}

	/**
	 * Hyperbolic cosine function.
	 * @returns {Matrix} cosh(A)
	 */
	cosh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.cosh();
		});
	}

	/**
	 * Inverse hyperbolic cosine function.
	 * @returns {Matrix} acosh(A)
	 */
	acosh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acosh();
		});
	}

	/**
	 * Hyperbolic tangent function.
	 * @returns {Matrix} tanh(A)
	 */
	tanh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tanh();
		});
	}
	
	/**
	 * Inverse hyperbolic tangent function.
	 * @returns {Matrix} atanh(A)
	 */
	atanh() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.atanh();
		});
	}

	/**
	 * Secant function.
	 * @returns {Matrix} sec(A)
	 */
	sec() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sec();
		});
	}

	/**
	 * Reverse secant function.
	 * @returns {Matrix} asec(A)
	 */
	asec() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.asec();
		});
	}

	/**
	 * Hyperbolic secant function.
	 * @returns {Matrix} sech(A)
	 */
	sech() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sech();
		});
	}

	/**
	 * Inverse hyperbolic secant function.
	 * @returns {Matrix} asech(A)
	 */
	asech() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.asech();
		});
	}

	/**
	 * Cotangent function.
	 * @returns {Matrix} cot(A)
	 */
	cot() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.cot();
		});
	}

	/**
	 * Inverse cotangent function.
	 * @returns {Matrix} acot(A)
	 */
	acot() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acot();
		});
	}

	/**
	 * Hyperbolic cotangent function.
	 * @returns {Matrix} coth(A)
	 */
	coth() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.coth();
		});
	}

	/**
	 * Inverse hyperbolic cotangent function.
	 * @returns {Matrix} acoth(A)
	 */
	acoth() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acoth();
		});
	}

	/**
	 * Cosecant function.
	 * @returns {Matrix} csc(A)
	 */
	csc() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.csc();
		});
	}

	/**
	 * Inverse cosecant function.
	 * @returns {Matrix} acsc(A)
	 */
	acsc() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acsc();
		});
	}

	/**
	 * Hyperbolic cosecant function.
	 * @returns {Matrix} csch(A)
	 */
	csch() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.csch();
		});
	}

	/**
	 * Inverse hyperbolic cosecant function.
	 * @returns {Matrix} acsch(A)
	 */
	acsch() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.acsch();
		});
	}

	// ----------------------
	// &#x78BA;&#x7387;&#x30FB;&#x7D71;&#x8A08;&#x7CFB;
	// ----------------------
	
	/**
	 * Logit function.
	 * @returns {Matrix} logit(A)
	 */
	logit() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.logit();
		});
	}

	// ----------------------
	// &#x4FE1;&#x53F7;&#x51E6;&#x7406;&#x7CFB;
	// ----------------------
	
	/**
	 * Normalized sinc function.
	 * @returns {Matrix} sinc(A)
	 */
	sinc() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.sinc();
		});
	}
	
	// ----------------------
	// &#x4E71;&#x6570;
	// ----------------------
	
	/**
	 * Generate a matrix composed of random values [0, 1) with uniform random numbers.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @param {Random} [random] - Class for creating random numbers.
	 * @returns {Matrix}
	 */
	static rand(dimension, column_length, random) {
		return Matrix.createMatrixDoEachCalculation(function() {
			return Complex.rand(random);
		}, dimension, column_length);
	}

	/**
	 * Generate a matrix composed of random values with normal distribution.
	 * @param {KMatrixInputData} dimension - Number of dimensions or rows.
	 * @param {KMatrixInputData} [column_length] - Number of columns.
	 * @param {Random} [random] - Class for creating random numbers.
	 * @returns {Matrix}
	 */
	static randn(dimension, column_length, random) {
		return Matrix.createMatrixDoEachCalculation(function() {
			return Complex.randn(random);
		}, dimension, column_length);
	}

	// ----------------------
	// &#x30C6;&#x30B9;&#x30C8;&#x7CFB;
	// ----------------------
	
	/**
	 * Test if each element of the matrix is integer.
	 * - 1 if true, 0 if false.
	 * - Use `isInteger` if you want to test first element.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testInteger(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isInteger(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * Test if each element of the matrix is complex integer.
	 * - 1 if true, 0 if false.
	 * - Use `isComplexInteger` if you want to test first element.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testComplexInteger(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isComplexInteger(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * real(this) === 0
	 * - 1 if true, 0 if false.
	 * - Use `isZero` if you want to test first element.
	 * - Use `isZeros` to check for a zero matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testZero(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isZero(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * real(this) === 1
	 * - 1 if true, 0 if false.
	 * - Use `isOne` if you want to test first element.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testOne(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isOne(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}
	
	/**
	 * Test if each element of the matrix is complex.
	 * - 1 if true, 0 if false.
	 * - Use `isComplex` to test whether a matrix contains complex numbers.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testComplex(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isComplex(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * Test if each element of the matrix is real.
	 * - 1 if true, 0 if false.
	 * - Use `isReal` to test for complex numbers in matrices.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testReal(tolerance) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isReal(tolerance) ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * Test if each element of the matrix is NaN.
	 * - 1 if true, 0 if false.
	 * - Use `isNaN` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testNaN() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isNaN() ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * real(this) &gt; 0
	 * - 1 if true, 0 if false.
	 * - Use `isPositive` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testPositive() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isPositive() ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * real(this) &lt; 0
	 * - 1 if true, 0 if false.
	 * - Use `isNegative` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testNegative() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isNegative() ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * real(this) &gt;= 0
	 * - 1 if true, 0 if false.
	 * - Use `isNotNegative` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testNotNegative() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isNotNegative() ? Complex.ONE : Complex.ZERO;
		});
	}

	/**
	 * Test if each element of the matrix is positive infinite.
	 * - 1 if true, 0 if false.
	 * - Use `isPositiveInfinity` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testPositiveInfinity() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isPositiveInfinity() ? Complex.ONE : Complex.ZERO;
		});
	}
	
	/**
	 * Test if each element of the matrix is negative infinite.
	 * - 1 if true, 0 if false.
	 * - Use `isNegativeInfinity` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testNegativeInfinity() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isNegativeInfinity() ? Complex.ONE : Complex.ZERO;
		});
	}
	
	/**
	 * Test if each element of the matrix is infinite.
	 * - 1 if true, 0 if false.
	 * - Use `isInfinite` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testInfinite() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isInfinite() ? Complex.ONE : Complex.ZERO;
		});
	}
	
	/**
	 * Test if each element of the matrix is finite.
	 * - 1 if true, 0 if false.
	 * - Use `isFinite` if you want to test first element.
	 * @returns {Matrix} Matrix with elements of the numerical value of 1 or 0.
	 */
	testFinite() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.isFinite() ? Complex.ONE : Complex.ZERO;
		});
	}


	// ----------------------
	// 1&#x8981;&#x7D20;&#x306E;&#x307F;&#x306E;&#x30C6;&#x30B9;&#x30C8;
	// ----------------------
	
	/**
	 * this === 0
	 * - Use only the first element.
	 * - Use `testZero` if you want to test the elements of a matrix.
	 * - Use `isZeros` to check for a zero matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isZero(tolerance) {
		return this.scalar().isZero(tolerance);
	}
	
	/**
	 * this === 1
	 * - Use only the first element.
	 * - Use `testOne` if you want to test the elements of a matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isOne(tolerance) {
		return this.scalar().isOne(tolerance);
	}
	
	/**
	 * this &gt; 0
	 * - Use only the first element.
	 * - Use `testPositive` if you want to test the elements of a matrix.
	 * @returns {boolean}
	 */
	isPositive() {
		return this.scalar().isPositive();
	}

	/**
	 * this &lt; 0
	 * - Use only the first element.
	 * - Use `testNegative` if you want to test the elements of a matrix.
	 * @returns {boolean}
	 */
	isNegative() {
		return this.scalar().isNegative();
	}

	/**
	 * this &gt;= 0
	 * - Use only the first element.
	 * - Use `testNotNegative` if you want to test the elements of a matrix.
	 * @returns {boolean}
	 */
	isNotNegative() {
		return this.scalar().isNotNegative();
	}
	
	/**
	 * this === NaN
	 * - Use only the first element.
	 * - Use `testNaN` if you want to test the elements of a matrix.
	 * @returns {boolean} isNaN(A)
	 */
	isNaN() {
		return this.scalar().isNaN();
	}
	
	/**
	 * this === Infinity
	 * - Use only the first element.
	 * - Use `testPositiveInfinity` if you want to test the elements of a matrix.
	 * @returns {boolean} isPositiveInfinity(A)
	 */
	isPositiveInfinity() {
		return this.scalar().isPositiveInfinity();
	}

	/**
	 * this === -Infinity
	 * - Use only the first element.
	 * - Use `testNegativeInfinity` if you want to test the elements of a matrix.
	 * @returns {boolean} isNegativeInfinity(A)
	 */
	isNegativeInfinity() {
		return this.scalar().isNegativeInfinity();
	}

	/**
	 * this === Infinity or -Infinity
	 * - Use only the first element.
	 * - Use `testInfinite` if you want to test the elements of a matrix.
	 * @returns {boolean} isPositiveInfinity(A) || isNegativeInfinity(A)
	 */
	isInfinite() {
		return this.scalar().isInfinite();
	}
	
	/**
	 * Return true if the value is finite number.
	 * - Use only the first element.
	 * - Use `testFinite` if you want to test the elements of a matrix.
	 * @returns {boolean} !isNaN(A) &amp;&amp; !isInfinite(A)
	 */
	isFinite() {
		return this.scalar().isFinite();
	}

	/**
	 * Return true if the value is integer.
	 * - Use only the first element.
	 * - Use `testFinite` if you want to test the elements of a matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isInteger(tolerance) {
		return this.scalar().isInteger(tolerance);
	}

	/**
	 * Returns true if the vallue is complex integer (including normal integer).
	 * - Use only the first element.
	 * - Use `testFinite` if you want to test the elements of a matrix.
	 * @param {KMatrixInputData} [tolerance] - Calculation tolerance of calculation.
	 * @returns {boolean} real(A) === integer &amp;&amp; imag(A) === integer
	 */
	isComplexInteger(tolerance) {
		return this.scalar().isComplexInteger(tolerance);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x884C;&#x5217;&#x306E;&#x8A08;&#x7B97;&#x3067;&#x3088;&#x304F;&#x4F7F;&#x7528;&#x3059;&#x308B;&#x51E6;&#x7406;&#x3002;
	// &#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x5185;&#x90E8;&#x306E;&#x51E6;&#x7406;&#x3092;&#x8A18;&#x8FF0;&#x3059;&#x308B;&#x969B;&#x306B;&#x4F7F;&#x7528;&#x3057;&#x3066;&#x3044;&#x308B;&#x3002;
	// &#x4ED6;&#x304B;&#x3089;&#x4F7F;&#x7528;&#x3059;&#x308B;&#x5834;&#x5408;&#x306F;&#x6CE8;&#x610F;&#x304C;&#x5FC5;&#x8981;&#x3067;&#x3042;&#x308B;&#x3002;
	// &#x524D;&#x63D0;&#x6761;&#x4EF6;&#x304C;&#x3042;&#x308B;&#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x3001;&#x30DF;&#x30E5;&#x30FC;&#x30BF;&#x30D6;&#x30EB;&#x3068;&#x306A;&#x3063;&#x3066;&#x3044;&#x308B;&#x3002;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Rotate matrix 90 degrees clockwise. (mutable)
	 * @param {KMatrixInputData} rot_90_count - Number of times rotated by 90 degrees.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @private
	 */
	_rot90(rot_90_count) {
		const count = Matrix._toInteger(rot_90_count);
		let rot_type = 1;
		if(arguments.length === 1) {
			rot_type = ((count % 4) + 4) % 4;
		}
		if(rot_type === 0) {
			return this;
		}
		// &#x30D0;&#x30C3;&#x30AF;&#x30A2;&#x30C3;&#x30D7;
		const x = new Array(this.row_length);
		for(let i = 0; i &lt; this.row_length; i++) {
			x[i] = new Array(this.column_length);
			for(let j = 0; j &lt; this.column_length; j++) {
				x[i][j] = this.matrix_array[i][j];
			}
		}
		const y = this.matrix_array;
		if(rot_type === 1) {
			// 90&#x5EA6;&#x56DE;&#x8EE2;
			y.splice(this.column_length);
			for(let col = 0; col &lt; this.column_length; col++) {
				if(col &lt; this.row_length) {
					y[col].splice(this.row_length);
				}
				else {
					y[col] = new Array(this.row_length);
				}
				for(let row = 0; row &lt; this.row_length; row++) {
					y[col][row] = x[this.row_length - row - 1][col];
				}
			}
		}
		else if(rot_type === 2) {
			// 180&#x5EA6;&#x56DE;&#x8EE2;
			for(let row = 0; row &lt; this.row_length; row++) {
				for(let col = 0; col &lt; this.column_length; col++) {
					y[row][col] = x[this.row_length - row - 1][this.column_length - col - 1];
				}
			}
		}
		else if(rot_type === 3) {
			// 270&#x5EA6;&#x56DE;&#x8EE2;
			y.splice(this.column_length);
			for(let col = 0; col &lt; this.column_length; col++) {
				if(col &lt; this.row_length) {
					y[col].splice(this.row_length);
				}
				else {
					y[col] = new Array(this.row_length);
				}
				for(let row = 0; row &lt; this.row_length; row++) {
					y[col][row] = x[row][this.column_length - col - 1];
				}
			}
		}
		this.row_length = y.length;
		this.column_length = y[0].length;
		this._clearCash();
		return this;
	}

	/**
	 * Rotate matrix 90 degrees clockwise.
	 * @param {KMatrixInputData} rot_90_count - Number of times rotated by 90 degrees.
	 * @returns {Matrix} Matrix after function processing.
	 */
	rot90(rot_90_count) {
		return this.clone()._rot90(rot_90_count);
	}

	/**
	 * Change the size of the matrix. (mutable)
	 * Initialized with 0 when expanding.
	 * @param {KMatrixInputData} new_row_length - Number of rows of matrix to resize.
	 * @param {KMatrixInputData} new_column_length - Number of columns of matrix to resize.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @ignore
	 */
	_resize(new_row_length, new_column_length) {
		const row_length	= Matrix._toInteger(new_row_length);
		const column_length	= Matrix._toInteger(new_column_length);
		if((row_length === this.row_length) &amp;&amp; (column_length === this.column_length)) {
			return this;
		}
		if((row_length &lt;= 0) || (column_length &lt;= 0)) {
			throw &quot;_resize&quot;;
		}
		const row_max = Math.max(this.row_length, row_length);
		const col_max = Math.max(this.column_length, column_length);
		const y = this.matrix_array;
		// &#x5927;&#x304D;&#x304F;&#x306A;&#x3063;&#x305F;&#x884C;&#x3068;&#x5217;&#x306B;&#x5BFE;&#x3057;&#x3066;&#x30BC;&#x30ED;&#x3067;&#x57CB;&#x3081;&#x308B;
		for(let row = 0; row &lt; row_max; row++) {
			if(row &gt;= this.row_length) {
				y[row] = new Array(col_max);
			}
			for(let col = 0; col &lt; col_max; col++) {
				if((row &gt;= this.row_length) || (col &gt;= this.column_length)) {
					y[row][col] = Complex.ZERO;
				}
			}
		}
		// &#x5C0F;&#x3055;&#x304F;&#x306A;&#x3063;&#x305F;&#x884C;&#x3068;&#x5217;&#x3092;&#x524A;&#x9664;&#x3059;&#x308B;
		if(this.row_length &gt; row_length) {
			y.splice(row_length);
		}
		if(this.column_length &gt; column_length) {
			for(let row = 0; row &lt; y.length; row++) {
				y[row].splice(column_length);
			}
		}
		this.row_length = row_length;
		this.column_length = column_length;
		this._clearCash();
		return this;
	}

	/**
	 * Change the size of the matrix.
	 * Initialized with 0 when expanding.
	 * @param {KMatrixInputData} row_length - Number of rows of matrix to resize.
	 * @param {KMatrixInputData} column_length - Number of columns of matrix to resize.
	 * @returns {Matrix} Matrix after function processing.
	 */
	resize(row_length, column_length) {
		return this.clone()._resize(row_length, column_length);
	}

	/**
	 * Remove the row in this matrix. (mutable)
	 * @param {KMatrixInputData} delete_row_index - Number of row of matrix to delete.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @private
	 */
	_deleteRow(delete_row_index) {
		const row_index	= Matrix._toInteger(delete_row_index);
		if((this.row_length === 1) || (this.row_length &lt;= row_index)) {
			throw &quot;_deleteRow&quot;;
		}
		this.matrix_array.splice(row_index, 1);
		this.row_length--;
		this._clearCash();
		return this;
	}
	
	/**
	 * Remove the column in this matrix. (mutable)
	 * @param {KMatrixInputData} delete_column_index - Number of column of matrix to delete.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @private
	 */
	_deleteColumn(delete_column_index) {
		const column_index	= Matrix._toInteger(delete_column_index);
		if((this.column_length === 1) || (this.column_length &lt;= column_index)) {
			throw &quot;_deleteColumn&quot;;
		}
		for(let row = 0; row &lt; this.row_length; row++) {
			this.matrix_array[row].splice(column_index, 1);
		}
		this.column_length--;
		this._clearCash();
		return this;
	}

	/**
	 * Remove the row in this matrix.
	 * @param {KMatrixInputData} delete_row_index - Number of row of matrix to delete.
	 * @returns {Matrix} Matrix after function processing.
	 */
	deleteRow(delete_row_index) {
		return this.clone()._deleteRow(delete_row_index);
	}

	/**
	 * Remove the column in this matrix.
	 * @param {KMatrixInputData} delete_column_index - Number of column of matrix to delete.
	 * @returns {Matrix} Matrix after function processing.
	 */
	deleteColumn(delete_column_index) {
		return this.clone()._deleteColumn(delete_column_index);
	}

	/**
	 * Swap rows in the matrix. (mutable)
	 * @param {KMatrixInputData} exchange_row_index1 - Number 1 of row of matrix to exchange.
	 * @param {KMatrixInputData} exchange_row_index2 - Number 2 of row of matrix to exchange.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @ignore
	 */
	_exchangeRow(exchange_row_index1, exchange_row_index2) {
		const row_index1	= Matrix._toInteger(exchange_row_index1);
		const row_index2	= Matrix._toInteger(exchange_row_index2);
		if((this.row_length === 1) || (this.row_length &lt;= row_index1) || (this.row_length &lt;= row_index2)) {
			throw &quot;_exchangeRow&quot;;
		}
		if(row_index1 === row_index2) {
			return this;
		}
		const swap = this.matrix_array[row_index1];
		this.matrix_array[row_index1] = this.matrix_array[row_index2];
		this.matrix_array[row_index2] = swap;
		this._clearCash();
		return this;
	}

	/**
	 * Swap columns in the matrix. (mutable)
	 * @param {KMatrixInputData} exchange_column_index1 - Number 1 of column of matrix to exchange.
	 * @param {KMatrixInputData} exchange_column_index2 - Number 2 of column of matrix to exchange.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @ignore
	 */
	_exchangeColumn(exchange_column_index1, exchange_column_index2) {
		const column_index1	= Matrix._toInteger(exchange_column_index1);
		const column_index2	= Matrix._toInteger(exchange_column_index2);
		if((this.column_length === 1) || (this.column_length &lt;= column_index1) || (this.column_length &lt;= column_index2)) {
			throw &quot;_exchangeColumn&quot;;
		}
		if(column_index1 === column_index2) {
			return this;
		}
		for(let row = 0; row &lt; this.row_length; row++) {
			const swap = this.matrix_array[row][column_index1];
			this.matrix_array[row][column_index1] = this.matrix_array[row][column_index2];
			this.matrix_array[row][column_index2] = swap;
		}
		this._clearCash();
		return this;
	}

	/**
	 * Swap rows in the matrix.
	 * @param {KMatrixInputData} exchange_row_index1 - Number 1 of row of matrix to exchange.
	 * @param {KMatrixInputData} exchange_row_index2 - Number 2 of row of matrix to exchange.
	 * @returns {Matrix} Matrix after function processing.
	 */
	exchangeRow(exchange_row_index1, exchange_row_index2) {
		return this.clone()._exchangeRow(exchange_row_index1, exchange_row_index2);
	}

	/**
	 * Swap columns in the matrix.
	 * @param {KMatrixInputData} exchange_column_index1 - Number 1 of column of matrix to exchange.
	 * @param {KMatrixInputData} exchange_column_index2 - Number 2 of column of matrix to exchange.
	 * @returns {Matrix} Matrix after function processing.
	 */
	exchangeColumn(exchange_column_index1, exchange_column_index2) {
		return this.clone()._exchangeColumn(exchange_column_index1, exchange_column_index2);
	}

	/**
	 * Combine matrix to the right of this matrix. (mutable)
	 * @param {KMatrixInputData} left_matrix - Matrix to combine.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @ignore
	 */
	_concatRight(left_matrix) {
		const M = Matrix._toMatrix(left_matrix);
		if(this.row_length != M.row_length) {
			throw &quot;_concatRight&quot;;
		}
		for(let row = 0; row &lt; this.row_length; row++) {
			for(let col = 0; col &lt; M.column_length; col++) {
				this.matrix_array[row].push(M.matrix_array[row][col]);
			}
		}
		this.column_length += M.column_length;
		this._clearCash();
		return this;
	}

	/**
	 * Combine matrix to the bottom of this matrix. (mutable)
	 * @param {KMatrixInputData} bottom_matrix - Matrix to combine.
	 * @returns {Matrix} Matrix after function processing. (this)
	 * @private
	 */
	_concatBottom(bottom_matrix) {
		const M = Matrix._toMatrix(bottom_matrix);
		if(this.column_length != M.column_length) {
			throw &quot;_concatBottom&quot;;
		}
		for(let row = 0; row &lt; M.row_length; row++) {
			this.matrix_array.push(M.matrix_array[row]);
		}
		this.row_length += M.row_length;
		this._clearCash();
		return this;
	}

	/**
	 * Combine matrix to the right of this matrix.
	 * @param {KMatrixInputData} left_matrix - Matrix to combine.
	 * @returns {Matrix} Matrix after function processing.
	 */
	concatRight(left_matrix) {
		return this.clone()._concatRight(left_matrix);
	}

	/**
	 * Combine matrix to the bottom of this matrix.
	 * @param {KMatrixInputData} bottom_matrix - Matrix to combine.
	 * @returns {Matrix} Matrix after function processing.
	 */
	concatBottom(bottom_matrix) {
		return this.clone()._concatBottom(bottom_matrix);
	}

	/**
	 * Clip each element of matrix to specified range.
	 * @param {KMatrixInputData} min 
	 * @param {KMatrixInputData} max 
	 * @returns {Matrix} min(max(x, min), max)
	 */
	clip(min, max) {
		const MIN = Matrix._toMatrix(min);
		const MAX = Matrix._toMatrix(max);
		const x_min = MIN.matrix_array;
		const x_max = MAX.matrix_array;
		return this.cloneMatrixDoEachCalculation(
			function(num, row, col) {
				const d_min = x_min[row % MIN.row_length][col % MIN.column_length];
				const d_max = x_max[row % MAX.row_length][col % MAX.column_length];
				return num.clip(d_min, d_max);
			}
		);
	}

	/**
	 * Create row vector with specified initial value, step value, end condition.
	 * @param {KMatrixInputData} start_or_stop 
	 * @param {KMatrixInputData} [stop]
	 * @param {KMatrixInputData} [step=1] 
	 * @returns {Matrix}
	 */
	static arange(start_or_stop, stop, step) {
		const from  = stop !== undefined ? Matrix._toComplex(start_or_stop) : Complex.ZERO;
		const to    = stop !== undefined ? Matrix._toComplex(stop) : Matrix._toComplex(start_or_stop);
		const delta = step !== undefined ? Matrix._toComplex(step) : Complex.ONE;
		return new Matrix(MatrixTool.InterpolationCalculation(from, delta, to, false));
	}

	/**
	 * Circular shift.
	 * @param {KMatrixInputData} shift_size 
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} Matrix after function processing.
	 */
	circshift(shift_size, type) {
		const shift = Matrix._toInteger(shift_size);
		const dim = !(type &amp;&amp; type.dimension) ? &quot;auto&quot; : type.dimension;
		/**
		 * @param {Array&lt;Complex&gt;} data 
		 * @returns {Array&lt;Complex&gt;}
		 */
		const main = function(data) {
			const y = new Array(data.length);
			let from = ((- shift % data.length) + data.length) % data.length;
			for(let i = 0; i &lt; data.length; i++) {
				y[i] = data[from++];
				if(from === data.length) {
					from = 0;
				}
			}
			return y;
		};
		return this.eachVector(main, dim);
	}

	/**
	 * Circular shift.
	 * @param {KMatrixInputData} shift_size 
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} Matrix after function processing.
	 */
	roll(shift_size, type) {
		return this.circshift(shift_size, type);
	}

	/**
	 * Change the shape of the matrix.
	 * The number of elements in the matrix doesn&apos;t increase or decrease.
	 * @param {KMatrixInputData} row_length - Number of rows of matrix to reshape.
	 * @param {KMatrixInputData} column_length - Number of columns of matrix to reshape.
	 * @returns {Matrix} Matrix after function processing.
	 */
	reshape(row_length, column_length) {
		const new_row_length = Matrix._toInteger(row_length);
		const new_column_length = Matrix._toInteger(column_length);
		const this_size = this.row_length * this.column_length;
		const new_size = new_row_length * new_column_length;
		if(this_size !== new_size) {
			throw &quot;reshape error. (this_size !== new_size)-&gt;(&quot; + this_size + &quot; !== &quot; + new_size + &quot;)&quot;;
		}
		const m = this.matrix_array;
		let m_col = 0;
		let m_row = 0;
		const y = new Array(new_row_length);
		for(let row = 0; row &lt; new_row_length; row++) {
			y[row] = new Array(new_column_length);
			for(let col = 0; col &lt; new_column_length; col++) {
				y[row][col] = m[m_row][m_col];
				m_col++;
				if(m_col === this.column_length) {
					m_col = 0;
					m_row++;
				}
			}
		}
		return new Matrix(y);
	}

	/**
	 * Flip this matrix left and right.
	 * @returns {Matrix} Matrix after function processing.
	 */
	fliplr() {
		return this.flip({dimension : &quot;row&quot;});
	}

	/**
	 * Flip this matrix up and down.
	 * @returns {Matrix} Matrix after function processing.
	 */
	flipud() {
		return this.flip({dimension : &quot;column&quot;});
	}

	/**
	 * Flip this matrix.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} Matrix after function processing.
	 */
	flip(type) {
		const dim = !(type &amp;&amp; type.dimension) ? &quot;auto&quot; : type.dimension;
		/**
		 * @param {Array&lt;Complex&gt;} data 
		 * @returns {Array&lt;Complex&gt;}
		 */
		const main = function(data) {
			const y = new Array(data.length);
			for(let i = 0, j = data.length - 1; i &lt; data.length; i++, j--) {
				y[i] = data[j];
			}
			return y;
		};
		return this.eachVector(main, dim);
	}

	/**
	 * Index sort.
	 * - Sorts by row when setting index by row vector to the argument.
	 * - Sorts by column when setting index by column vector to the argument.
	 * @param {KMatrixInputData} v - Vector with index. (See the description of this function)
	 * @returns {Matrix} Matrix after function processing.
	 */
	indexsort(v) {
		const V = Matrix._toMatrix(v);
		if(V.isMatrix()) {
			throw &quot;argsort error. argsort is not vector. (&quot; + V.toOneLineString + &quot;)&quot;;
		}
		let is_transpose = false;
		let target_array = null;
		let index_array = null;
		if(V.isRow()) {
			if(this.column_length !== V.column_length) {
				throw &quot;argsort error. (this_size !== new_size)-&gt;(&quot; + this.column_length + &quot; !== &quot; + V.column_length + &quot;)&quot;;
			}
			// &#x5217;&#x3092;&#x30A4;&#x30F3;&#x30C7;&#x30C3;&#x30AF;&#x30B9;&#x30BD;&#x30FC;&#x30C8;&#x3059;&#x308B;
			is_transpose = true;
			target_array = this.transpose().matrix_array;
			index_array = V.matrix_array[0];
		}
		if(V.isColumn()) {
			if(this.row_length !== V.row_length) {
				throw &quot;argsort error. (this_size !== new_size)-&gt;(&quot; + this.row_length + &quot; !== &quot; + V.row_length + &quot;)&quot;;
			}
			// &#x884C;&#x3092;&#x30A4;&#x30F3;&#x30C7;&#x30C3;&#x30AF;&#x30B9;&#x30BD;&#x30FC;&#x30C8;&#x3059;&#x308B;
			target_array = this.matrix_array;
			index_array = V.transpose().matrix_array[0];
		}
		// &#x30C7;&#x30FC;&#x30BF;&#x3092;&#x4ED8;&#x3051;&#x66FF;&#x3048;&#x308B;
		const sort_data = new Array(index_array.length);
		for(let i = 0; i &lt; index_array.length; i++) {
			sort_data[i] = {
				index : index_array[i],
				data : target_array[i]
			};
		}
		/**
		 * &#x6BD4;&#x8F03;&#x95A2;&#x6570;&#x3092;&#x4F5C;&#x6210;
		 * @type {function({index : Complex}, {index : Complex}): number }
		 */
		const compare = function(a, b) {
			return a.index.compareTo(b.index);
		};
		{
			/**
			 * @type {Array&lt;{index : Complex}&gt;}
			 */
			const temp = [];
			/**
			 * &#x30BD;&#x30FC;&#x30C8;&#x95A2;&#x6570;&#xFF08;&#x5B89;&#x5B9A;&#x30DE;&#x30FC;&#x30B8;&#x30BD;&#x30FC;&#x30C8;&#xFF09;
			 * @param {Array&lt;{index : Complex}&gt;} elements 
			 * @param {number} first 
			 * @param {number} last 
			 * @param {function({index : Complex}, {index : Complex}): number} cmp_function 
			 * @returns {boolean}
			 */
			const sort = function(elements, first, last, cmp_function) { 
				if(first &lt; last) {
					const middle = Math.floor((first + last) / 2);
					sort(elements, first, middle, cmp_function);
					sort(elements, middle + 1, last, cmp_function);
					let p = 0, i, j, k;
					for(i = first; i &lt;= middle; i++) {
						temp[p++] = elements[i];
					}
					i = middle + 1;
					j = 0;
					k = first;
					while((i &lt;= last) &amp;&amp; (j &lt; p)) {
						if(cmp_function(elements[i], temp[j]) &gt;= 0) {
							elements[k++] = temp[j++];
						}
						else {
							elements[k++] = elements[i++];
						}
					}
					while(j &lt; p) {
						elements[k++] = temp[j++];
					}
				}
				return true;
			};
			sort(sort_data, 0, sort_data.length - 1, compare);
		}
		// &#x884C;&#x5217;&#x3092;&#x7D44;&#x307F;&#x7ACB;&#x3066;&#x306A;&#x304A;&#x3059;
		const y = new Array(index_array.length);
		for(let i = 0; i &lt; index_array.length; i++) {
			y[i] = sort_data[i].data;
		}
		// &#x884C;&#x5217;&#x3092;&#x4F5C;&#x6210;&#x3059;&#x308B;
		const Y = new Matrix(y);
		if(!is_transpose) {
			return Y;
		}
		else {
			return Y.transpose();
		}
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// &#x884C;&#x5217;&#x306E;&#x4E00;&#x822C;&#x8A08;&#x7B97;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Transpose a matrix.
	 * @returns {Matrix} A^T
	 */
	transpose() {
		const y = new Array(this.column_length);
		for(let col = 0; col &lt; this.column_length; col++) {
			y[col] = new Array(this.row_length);
			for(let row = 0; row &lt; this.row_length; row++) {
				y[col][row] = this.matrix_array[row][col];
			}
		}
		return new Matrix(y);
	}

	/**
	 * Hermitian transpose.
	 * @returns {Matrix} A^T
	 */
	ctranspose() {
		return this.transpose().conj();
	}

	/**
	 * Hermitian transpose.
	 * @returns {Matrix} A^T
	 */
	T() {
		return this.ctranspose();
	}

	/**
	 * Inner product/Dot product.
	 * @param {KMatrixInputData} number 
	 * @param {KMatrixInputData} [dimension=1] - Dimension of matrix used for calculation. (1 or 2)
	 * @returns {Matrix} A&#x30FB;B
	 */
	inner(number, dimension=1) {
		return LinearAlgebra.inner(this, number, dimension);
	}
	
	/**
	 * LUP decomposition.
	 * - P&apos;*L*U=A
	 * - P is permutation matrix.
	 * - L is lower triangular matrix.
	 * - U is upper triangular matrix.
	 * @returns {{P: Matrix, L: Matrix, U: Matrix}} {L, U, P}
	 */
	lup() {
		return LinearAlgebra.lup(this);
	}

	/**
	 * LU decomposition.
	 * - L*U=A
	 * - L is lower triangular matrix.
	 * - U is upper triangular matrix.
	 * @returns {{L: Matrix, U: Matrix}} {L, U}
	 */
	lu() {
		return LinearAlgebra.lu(this);
	}

	/**
	 * Solving a system of linear equations to be Ax = B
	 * @param {KMatrixInputData} number - B
	 * @returns {Matrix} x
	 */
	linsolve(number) {
		return LinearAlgebra.linsolve(this, number);
	}

	/**
	 * QR decomposition.
	 * - Q*R=A
	 * - Q is orthonormal matrix.
	 * - R is upper triangular matrix.
	 * @returns {{Q: Matrix, R: Matrix}} {Q, R}
	 */
	qr() {
		return LinearAlgebra.qr(this);
	}

	/**
	 * Tridiagonalization of symmetric matrix.
	 * - Don&apos;t support complex numbers.
	 * - P*H*P&apos;=A
	 * - P is orthonormal matrix.
	 * - H is tridiagonal matrix.
	 * - The eigenvalues of H match the eigenvalues of A.
	 * @returns {{P: Matrix, H: Matrix}} {P, H}
	 */
	tridiagonalize() {
		return LinearAlgebra.tridiagonalize(this);
	}

	/**
	 * Eigendecomposition of symmetric matrix.
	 * - Don&apos;t support complex numbers.
	 * - V*D*V&apos;=A.
	 * - V is orthonormal matrix. and columns of V are the right eigenvectors.
	 * - D is a matrix containing the eigenvalues on the diagonal component.
	 * @returns {{V: Matrix, D: Matrix}} {D, V}
	 */
	eig() {
		return LinearAlgebra.eig(this);
	}

	/**
	 * Singular Value Decomposition (SVD).
	 * - U*S*V&apos;=A
	 * - U and V are orthonormal matrices.
	 * - S is a matrix with singular values in the diagonal.
	 * @returns {{U: Matrix, S: Matrix, V: Matrix}} U*S*V&apos;=A
	 */
	svd() {
		return LinearAlgebra.svd(this);
	}

	/**
	 * Pseudo-inverse matrix.
	 * @returns {Matrix} A^+
	 */
	pinv() {
		return LinearAlgebra.pinv(this);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// probability &#x78BA;&#x7387;&#x8A08;&#x7B97;&#x7528;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Log-gamma function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	gammaln() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gammaln();
		});
	}

	/**
	 * Gamma function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	gamma() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gamma();
		});
	}

	/**
	 * Incomplete gamma function.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} a
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {Matrix}
	 */
	gammainc(a, tail) {
		const a_ = Matrix._toDouble(a);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gammainc(a_, tail);
		});
	}

	/**
	 * Probability density function (PDF) of the gamma distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - Shape parameter.
	 * @param {KMatrixInputData} s - Scale parameter.
	 * @returns {Matrix}
	 */
	gampdf(k, s) {
		const k_ = Matrix._toDouble(k);
		const s_ = Matrix._toDouble(s);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gampdf(k_, s_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of gamma distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - Shape parameter.
	 * @param {KMatrixInputData} s - Scale parameter.
	 * @returns {Matrix}
	 */
	gamcdf(k, s) {
		const k_ = Matrix._toDouble(k);
		const s_ = Matrix._toDouble(s);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gamcdf(k_, s_);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of gamma distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - Shape parameter.
	 * @param {KMatrixInputData} s - Scale parameter.
	 * @returns {Matrix}
	 */
	gaminv(k, s) {
		const k_ = Matrix._toDouble(k);
		const s_ = Matrix._toDouble(s);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.gaminv(k_, s_);
		});
	}

	/**
	 * Beta function.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} y
	 * @returns {Matrix}
	 */
	beta(y) {
		const y_ = Matrix._toDouble(y);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.beta(y_);
		});
	}
	
	/**
	 * Incomplete beta function.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} a
	 * @param {KMatrixInputData} b
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {Matrix}
	 */
	betainc(a, b, tail) {
		const a_ = Matrix._toDouble(a);
		const b_ = Matrix._toDouble(b);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.betainc(a_, b_, tail);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of beta distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} a
	 * @param {KMatrixInputData} b
	 * @returns {Matrix}
	 */
	betacdf(a, b) {
		const a_ = Matrix._toDouble(a);
		const b_ = Matrix._toDouble(b);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.betacdf(a_, b_);
		});
	}

	/**
	 * Probability density function (PDF) of beta distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} a
	 * @param {KMatrixInputData} b
	 * @returns {Matrix}
	 */
	betapdf(a, b) {
		const a_ = Matrix._toDouble(a);
		const b_ = Matrix._toDouble(b);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.betapdf(a_, b_);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of beta distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} a
	 * @param {KMatrixInputData} b
	 * @returns {Matrix}
	 */
	betainv(a, b) {
		const a_ = Matrix._toDouble(a);
		const b_ = Matrix._toDouble(b);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.betainv(a_, b_);
		});
	}

	/**
	 * Factorial function, x!.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	factorial() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.factorial();
		});
	}
	
	/**
	 * Binomial coefficient, number of all combinations, nCk.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k
	 * @returns {Matrix}
	 */
	nchoosek(k) {
		const k_ = Matrix._toDouble(k);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.nchoosek(k_);
		});
	}
	
	/**
	 * Error function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	erf() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.erf();
		});
	}

	/**
	 * Complementary error function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	erfc() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.erfc();
		});
	}
	
	/**
	 * Inverse function of Error function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	erfinv() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.erfinv();
		});
	}
	
	/**
	 * Inverse function of Complementary error function.
	 * - Calculate from real values.
	 * @returns {Matrix}
	 */
	erfcinv() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.erfcinv();
		});
	}

	/**
	 * Probability density function (PDF) of normal distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} [u=0.0] - Average value.
	 * @param {KMatrixInputData} [s=1.0] - Variance value.
	 * @returns {Matrix}
	 */
	normpdf(u, s) {
		const u_ = u !== undefined ? Matrix._toDouble(u) : 0.0;
		const s_ = s !== undefined ? Matrix._toDouble(s) : 1.0;
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.normpdf(u_, s_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of normal distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} [u=0.0] - Average value.
	 * @param {KMatrixInputData} [s=1.0] - Variance value.
	 * @returns {Matrix}
	 */
	normcdf(u, s) {
		const u_ = u !== undefined ? Matrix._toDouble(u) : 0.0;
		const s_ = s !== undefined ? Matrix._toDouble(s) : 1.0;
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.normcdf(u_, s_);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of normal distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} [u=0.0] - Average value.
	 * @param {KMatrixInputData} [s=1.0] - Variance value.
	 * @returns {Matrix}
	 */
	norminv(u, s) {
		const u_ = u !== undefined ? Matrix._toDouble(u) : 0.0;
		const s_ = s !== undefined ? Matrix._toDouble(s) : 1.0;
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.norminv(u_, s_);
		});
	}

	/**
	 * Probability density function (PDF) of binomial distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} n
	 * @param {KMatrixInputData} p
	 * @returns {Matrix}
	 */
	binopdf(n, p) {
		const n_ = Matrix._toDouble(n);
		const p_ = Matrix._toDouble(p);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.binopdf(n_, p_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of binomial distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} n
	 * @param {KMatrixInputData} p
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {Matrix}
	 */
	binocdf(n, p, tail) {
		const n_ = Matrix._toDouble(n);
		const p_ = Matrix._toDouble(p);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.binocdf(n_, p_, tail);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of binomial distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} n
	 * @param {KMatrixInputData} p
	 * @returns {Matrix}
	 */
	binoinv(n, p) {
		const n_ = Matrix._toDouble(n);
		const p_ = Matrix._toDouble(p);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.binoinv(n_, p_);
		});
	}

	/**
	 * Probability density function (PDF) of Poisson distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} lambda
	 * @returns {Matrix}
	 */
	poisspdf(lambda) {
		const lambda_ = Matrix._toDouble(lambda);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.poisspdf(lambda_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of Poisson distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} lambda
	 * @returns {Matrix}
	 */
	poisscdf(lambda) {
		const lambda_ = Matrix._toDouble(lambda);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.poisscdf(lambda_);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of Poisson distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} lambda
	 * @returns {Matrix}
	 */
	poissinv(lambda) {
		const lambda_ = Matrix._toDouble(lambda);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.poissinv(lambda_);
		});
	}

	/**
	 * Probability density function (PDF) of Student&apos;s t-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} v - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	tpdf(v) {
		const v_ = Matrix._toDouble(v);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tpdf(v_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of Student&apos;s t-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} v - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	tcdf(v) {
		const v_ = Matrix._toDouble(v);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tcdf(v_);
		});
	}

	/**
	 * Inverse of cumulative distribution function (CDF) of Student&apos;s t-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} v - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	tinv(v) {
		const v_ = Matrix._toDouble(v);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tinv(v_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of Student&apos;s t-distribution that can specify tail.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} v - The degrees of freedom. (DF)
	 * @param {KMatrixInputData} tails - Tail. (1 = the one-tailed distribution, 2 =  the two-tailed distribution.)
	 * @returns {Matrix}
	 */
	tdist(v, tails) {
		const v_ = Matrix._toDouble(v);
		const tails_ = Matrix._toDouble(tails);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tdist(v_, tails_);
		});
	}

	/**
	 * Inverse of cumulative distribution function (CDF) of Student&apos;s t-distribution in two-sided test.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} v - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	tinv2(v) {
		const v_ = Matrix._toDouble(v);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.tinv2(v_);
		});
	}

	/**
	 * Probability density function (PDF) of chi-square distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	chi2pdf(k) {
		const k_ = Matrix._toDouble(k);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.chi2pdf(k_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of chi-square distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	chi2cdf(k) {
		const k_ = Matrix._toDouble(k);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.chi2cdf(k_);
		});
	}
	
	/**
	 * Inverse function of cumulative distribution function (CDF) of chi-square distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} k - The degrees of freedom. (DF)
	 * @returns {Matrix}
	 */
	chi2inv(k) {
		const k_ = Matrix._toDouble(k);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.chi2inv(k_);
		});
	}

	/**
	 * Probability density function (PDF) of F-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} d1 - The degree of freedom of the molecules.
	 * @param {KMatrixInputData} d2 - The degree of freedom of the denominator
	 * @returns {Matrix}
	 */
	fpdf(d1, d2) {
		const d1_ = Matrix._toDouble(d1);
		const d2_ = Matrix._toDouble(d2);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.fpdf(d1_, d2_);
		});
	}

	/**
	 * Cumulative distribution function (CDF) of F-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} d1 - The degree of freedom of the molecules.
	 * @param {KMatrixInputData} d2 - The degree of freedom of the denominator
	 * @returns {Matrix}
	 */
	fcdf(d1, d2) {
		const d1_ = Matrix._toDouble(d1);
		const d2_ = Matrix._toDouble(d2);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.fcdf(d1_, d2_);
		});
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of F-distribution.
	 * - Calculate from real values.
	 * @param {KMatrixInputData} d1 - The degree of freedom of the molecules.
	 * @param {KMatrixInputData} d2 - The degree of freedom of the denominator
	 * @returns {Matrix}
	 */
	finv(d1, d2) {
		const d1_ = Matrix._toDouble(d1);
		const d2_ = Matrix._toDouble(d2);
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.finv(d1_, d2_);
		});
	}

	// ----------------------
	// &#x30D3;&#x30C3;&#x30C8;&#x6F14;&#x7B97;&#x7CFB;
	// ----------------------
	
	/**
	 * Logical AND.
	 * - Calculated as an integer.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A &amp; B
	 */
	and(number) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.and(Matrix._toDouble(number));
		});
	}

	/**
	 * Logical OR.
	 * - Calculated as an integer.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A | B
	 */
	or(number) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.or(Matrix._toDouble(number));
		});
	}

	/**
	 * Logical Exclusive-OR.
	 * - Calculated as an integer.
	 * @param {KMatrixInputData} number 
	 * @returns {Matrix} A ^ B
	 */
	xor(number) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.xor(Matrix._toDouble(number));
		});
	}

	/**
	 * Logical Not. (mutable)
	 * - Calculated as an integer.
	 * @returns {Matrix} !A
	 */
	not() {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.not();
		});
	}
	
	/**
	 * this &lt;&lt; n
	 * - Calculated as an integer.
	 * @param {KMatrixInputData} n
	 * @returns {Matrix} A &lt;&lt; n
	 */
	shift(n) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.shift(Matrix._toDouble(n));
		});
	}

	// ----------------------
	// &#x305D;&#x306E;&#x4ED6;&#x306E;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Multiply a multiple of ten.
	 * @param {KMatrixInputData} n
	 * @returns {Matrix} x * 10^n
	 */
	scaleByPowerOfTen(n) {
		return this.cloneMatrixDoEachCalculation(function(num) {
			return num.scaleByPowerOfTen(Matrix._toComplex(n));
		});
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// statistics &#x7D71;&#x8A08;&#x8A08;&#x7B97;&#x7528;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Maximum number.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} max([A, B])
	 */
	max(type) {
		return Statistics.max(this, type);
	}
	
	/**
	 * Minimum number.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} min([A, B])
	 */
	min(type) {
		return Statistics.min(this, type);
	}
	
	/**
	 * Sum.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	sum(type) {
		return Statistics.sum(this, type);
	}

	/**
	 * Arithmetic average.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	mean(type) {
		return Statistics.mean(this, type);
	}

	/**
	 * Product of array elements.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	prod(type) {
		return Statistics.prod(this, type);
	}

	/**
	 * Geometric mean.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	geomean(type) {
		return Statistics.geomean(this, type);
	}

	/**
	 * Median.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	median(type) {
		return Statistics.median(this, type);
	}

	/**
	 * Mode.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	mode(type) {
		return Statistics.mode(this, type);
	}

	/**
	 * Moment.
	 * - Moment of order n. Equivalent to the definition of variance at 2.
	 * @param {number} nth_order
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	moment(nth_order, type) {
		return Statistics.moment(this, nth_order, type);
	}

	/**
	 * Variance.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	variance(type) {
		return Statistics.variance(this, type);
	}

	/**
	 * Standard deviation.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	std(type) {
		return Statistics.std(this, type);
	}

	/**
	 * Mean absolute deviation.
	 * - The &quot;algorithm&quot; can choose &quot;0/mean&quot;(default) and &quot;1/median&quot;.
	 * @param {?string|?number} [algorithm]
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	mad(algorithm, type) {
		return Statistics.mad(this, algorithm, type);
	}

	/**
	 * Skewness.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	skewness(type) {
		return Statistics.skewness(this, type);
	}

	/**
	 * Covariance matrix or Covariance value.
	 * - Get a variance-covariance matrix from 1 matrix.
	 * - Get a covariance from 2 vectors.
	 * @param {KMatrixSettings|KMatrixInputData} [y_or_type]
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	cov(y_or_type, type) {
		return Statistics.cov(this, y_or_type, type);
	}

	/**
	 * The samples are standardize to a mean value of 0, standard deviation of 1.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	standardization(type) {
		return Statistics.standardization(this, type);
	}

	/**
	 * Correlation matrix or Correlation coefficient.
	 * - Get a correlation matrix from 1 matrix.
	 * - Get a correlation coefficient from 2 vectors.
	 * @param {KMatrixSettings|KMatrixInputData} [y_or_type]
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	corrcoef(y_or_type, type) {
		return Statistics.corrcoef(this, y_or_type, type);
	}

	/**
	 * Sort.
	 * - The &quot;order&quot; can choose &quot;ascend&quot;(default) and &quot;descend&quot;.
	 * @param {string} [order]
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	sort(order, type) {
		return Statistics.sort(this, order, type);
	}

	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
	// signal &#x4FE1;&#x53F7;&#x51E6;&#x7406;&#x7528;
	// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

	/**
	 * Discrete Fourier transform (DFT).
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} fft(x)
	 */
	fft(type) {
		return Signal.fft(this, type);
	}

	/**
	 * Inverse discrete Fourier transform (IDFT).
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} ifft(x)
	 */
	ifft(type) {
		return Signal.ifft(this, type);
	}

	/**
	 * Power spectral density.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} abs(fft(x)).^2
	 */
	powerfft(type) {
		return Signal.powerfft(this, type);
	}

	/**
	 * Discrete cosine transform (DCT-II, DCT).
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} dct(x)
	 */
	dct(type) {
		return Signal.dct(this, type);
	}

	/**
	 * Inverse discrete cosine transform (DCT-III, IDCT).
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix} idct(x)
	 */
	idct(type) {
		return Signal.idct(this, type);
	}

	/**
	 * Discrete two-dimensional Fourier transform (2D DFT).
	 * @returns {Matrix}
	 */
	fft2() {
		return Signal.fft2(this);
	}

	/**
	 * Inverse discrete two-dimensional Fourier transform (2D IDFT).
	 * @returns {Matrix}
	 */
	ifft2() {
		return Signal.ifft2(this);
	}

	/**
	 * Discrete two-dimensional cosine transform (2D DCT).
	 * @returns {Matrix}
	 */
	dct2() {
		return Signal.dct2(this);
	}

	/**
	 * Inverse discrete two-dimensional cosine transform (2D IDCT).
	 * @returns {Matrix}
	 */
	idct2() {
		return Signal.idct2(this);
	}

	/**
	 * Convolution integral, Polynomial multiplication.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix}
	 */
	conv(number) {
		return Signal.conv(this, number);
	}

	/**
	 * ACF(Autocorrelation function), cros-correlation function.
	 * - If the argument is omitted, it is calculated by the autocorrelation function.
	 * @param {KMatrixInputData} [number] - Matrix to calculate the correlation.
	 * @returns {Matrix}
	 */
	xcorr(number) {
		return Signal.xcorr(this, number);
	}

	/**
	 * Create window function for signal processing.
	 * The following window functions are available.
	 * - &quot;rectangle&quot;: Rectangular window
	 * - &quot;hann&quot;: Hann/Hanning window.
	 * - &quot;hamming&quot;: Hamming window.
	 * - &quot;blackman&quot;: Blackman window.
	 * - &quot;blackmanharris&quot;: Blackman-Harris window.
	 * - &quot;blackmannuttall&quot;: Blackman-Nuttall window.
	 * - &quot;flattop&quot;: Flat top window.
	 * - &quot;sin&quot;, Half cycle sine window.
	 * - &quot;vorbis&quot;, Vorbis window.
	 * @param {string} name - Window function name.
	 * @param {KMatrixInputData} size - Window length
	 * @param {string|number} [periodic=&quot;symmetric&quot;] - 0/&quot;symmetric&quot; (default) , 1/&quot;periodic&quot;
	 * @returns {Matrix} Column vector.
	 */
	static window(name, size, periodic) {
		return Signal.window(name, size, periodic);
	}

	/**
	 * Hann (Hanning) window.
	 * @param {KMatrixInputData} size - Window length
	 * @param {string|number} [periodic=&quot;symmetric&quot;] - 0/&quot;symmetric&quot; (default) , 1/&quot;periodic&quot;
	 * @returns {Matrix} Column vector.
	 */
	static hann(size, periodic) {
		return Signal.hann(size, periodic);
	}
	
	/**
	 * Hamming window.
	 * @param {KMatrixInputData} size - Window length
	 * @param {string|number} [periodic=&quot;symmetric&quot;] - 0/&quot;symmetric&quot; (default) , 1/&quot;periodic&quot;
	 * @returns {Matrix} Column vector.
	 */
	static hamming(size, periodic) {
		return Signal.hamming(size, periodic);
	}
	
	/**
	 * FFT shift.
	 * Circular shift beginning at the center of the signal.
	 * @param {KMatrixSettings} [type]
	 * @returns {Matrix}
	 */
	fftshift(type) {
		return Signal.fftshift(this, type);
	}
	// ----------------------
	// &#x4E92;&#x63DB;&#x6027;
	// ----------------------
	
	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {Matrix}
	 */
	signum() {
		return this.sign();
	}

	/**
	 * Subtract.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix} A - B
	 */
	subtract(number) {
		return this.sub(number);
	}

	/**
	 * Multiply.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix} A * B
	 */
	multiply(number) {
		return this.mul(number);
	}

	/**
	 * Divide.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix} fix(A / B)
	 */
	divide(number) {
		return this.div(number);
	}

	/**
	 * Remainder of division.
	 * - Result has same sign as the Dividend.
	 * @param {KMatrixInputData} number
	 * @returns {Matrix} A % B
	 */
	remainder(number) {
		return this.rem(number);
	}
	
	/**
	 * To integer rounded down to the nearest.
	 * @returns {Matrix} fix(A), trunc(A)
	 */
	trunc() {
		return this.fix();
	}

	/**
	 * @returns {boolean} true
	 * @private
	 */
	isMatrixData() {
		return true;
	}

}

// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;
// &#x5B9A;&#x6570;
// &#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;&#x25C6;

/**
 * 1
 * @type {Matrix}
 */
Matrix.ONE = new Matrix(1);

/**
 * 2
 * @type {Matrix}
 */
Matrix.TWO = new Matrix(2);

/**
 * 10
 * @type {Matrix}
 */
Matrix.TEN = new Matrix(10);

/**
 * 0
 * @type {Matrix}
 */
Matrix.ZERO = new Matrix(0);

/**
 * -1
 * @type {Matrix}
 */
Matrix.MINUS_ONE = new Matrix(-1);

/**
 * i, j
 * @type {Matrix}
 */
Matrix.I = new Matrix(Complex.I);

/**
 * PI.
 * @type {Matrix}
 */
Matrix.PI = new Matrix(Math.PI);

/**
 * 0.25 * PI.
 * @type {Matrix}
 */
Matrix.QUARTER_PI = new Matrix(0.25 * Math.PI);

/**
 * 0.5 * PI.
 * @type {Matrix}
 */
Matrix.HALF_PI = new Matrix(0.5 * Math.PI);

/**
 * 2 * PI.
 * @type {Matrix}
 */
Matrix.TWO_PI = new Matrix(2.0 * Math.PI);

/**
 * E, Napier&apos;s constant.
 * @type {Matrix}
 */
Matrix.E = new Matrix(Math.E);

/**
 * log_e(2)
 * @type {Matrix}
 */
Matrix.LN2 = new Matrix(Math.LN2);

/**
 * log_e(10)
 * @type {Matrix}
 */
Matrix.LN10 = new Matrix(Math.LN10);

/**
 * log_2(e)
 * @type {Matrix}
 */
Matrix.LOG2E = new Matrix(Math.LOG2E);

/**
 * log_10(e)
 * @type {Matrix}
 */
Matrix.LOG10E = new Matrix(Math.LOG10E);

/**
 * sqrt(2)
 * @type {Matrix}
 */
Matrix.SQRT2 = new Matrix(Math.SQRT2);

/**
 * sqrt(0.5)
 * @type {Matrix}
 */
Matrix.SQRT1_2 = new Matrix(Math.SQRT1_2);

/**
 * 0.5
 * @type {Matrix}
 */
Matrix.HALF = new Matrix(0.5);

/**
 * Positive infinity.
 * @type {Matrix}
 */
Matrix.POSITIVE_INFINITY = new Matrix(Number.POSITIVE_INFINITY);

/**
 * Negative Infinity.
 * @type {Matrix}
 */
Matrix.NEGATIVE_INFINITY = new Matrix(Number.NEGATIVE_INFINITY);

/**
 * Not a Number.
 * @type {Matrix}
 */
Matrix.NaN = new Matrix(Number.NaN);
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
