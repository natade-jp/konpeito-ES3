<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/math/core/tools/Probability.js | konpeito_es3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito_es3"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito-ES3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-konpeitoES3">konpeitoES3</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core">math/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Complex.js~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KComplexInputData">KComplexInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixInputData">KMatrixInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixSettings">KMatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-tools">math/core/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/LinearAlgebra.js~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Probability.js~Probability.html">Probability</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KStatisticsSettings">KStatisticsSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis.js~DataAnalysis.html">DataAnalysis</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools-dataanalysis">math/tools/DataAnalysis</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/MultipleRegressionAnalysis.js~MultipleRegressionAnalysis.html">MultipleRegressionAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/PrincipalComponentAnalysis.js~PrincipalComponentAnalysis.html">PrincipalComponentAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisAnova">KMultipleRegressionAnalysisAnova</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisOutput">KMultipleRegressionAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegression">KMultipleRegressionAnalysisPartialRegression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegressionData">KMultipleRegressionAnalysisPartialRegressionData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisSettings">KMultipleRegressionAnalysisSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisVectorState">KMultipleRegressionAnalysisVectorState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponent">KPrincipalComponent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisOutput">KPrincipalComponentAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisSettings">KPrincipalComponentAnalysisSettings</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/core/tools/Probability.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito-ES3.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */

/**
 * Return true if the value is integer.
 * @param {number} x
 * @returns {boolean}
 * @ignore
 */
const isInteger = function(x) {
	return (x - Math.trunc(x) !== 0.0);
};

/**
 * Collection for calculating probability using real numbers.
 * - These methods can be used in the `Matrix`, `Complex` method chain.
 * - This class cannot be called directly.
 */
export default class Probability {

	/**
	 * Log-gamma function.
	 * @param {number} x
	 * @returns {number}
	 */
	static gammaln(x) {
		if(!isFinite(x)) {
			if(isNaN(x)) {
				return NaN;
			}
			else {
				return Infinity;
			}
		}
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p30,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		const LOG_2PI = Math.log(2.0 * Math.PI);
		//&#x30D9;&#x30EB;&#x30CC;&#x30FC;&#x30A4;&#x6570;
		//http://fr.wikipedia.org/wiki/Nombre_de_Bernoulli
		const K2 = ( 1.0 / 6.0)					/ (2 * 1);
		const K4 = (-1.0 / 30.0)				/ (4 * 3);
		const K6 = ( 1.0 / 42.0)				/ (6 * 5);
		const K8 = (-1.0 / 30.0)				/ (8 * 7);
		const K10 = ( 5.0 / 66.0)				/ (10 * 9);
		const K12 = (-691.0 / 2730.0)			/ (12 * 11);
		const K14 = ( 7.0 / 6.0)				/ (14 * 13);
		const K16 = (-3617.0 / 510.0)			/ (16 * 15);
		const K18 = (43867.0 / 798.0)			/ (18 * 17);
		const K20 = (-174611.0 / 330.0)			/ (20 * 19);
		const K22 = (854513.0 / 138.0)			/ (22 * 21);
		const K24 = (-236364091.0 / 2730.0)		/ (24 * 23);
		const K26 = (8553103.0 / 6.0)			/ (26 * 25);
		const K28 = (-23749461029.0 / 870.0)	/ (28 * 27);
		const K30 = (8615841276005.0 / 14322.0)	/ (30 * 29);
		const K32 = (-7709321041217.0 / 510.0)	/ (32 * 31);
		const LIST = [
			K32, K30, K28, K26, K24, K22, K20, K18,
			K16, K14, K12, K10, K8, K6, K4, K2
		];
		let v = 1;
		let lx = x;
		while(lx &lt; LIST.length) {
			v *= lx;
			lx++;
		}
		const w = 1 / (lx * lx);
		let y = LIST[0];
		for(let i = 1; i &lt; LIST.length; i++) {
			y *= w;
			y += LIST[i];
		}
		y /= lx;
		y += 0.5 * LOG_2PI;
		y += - Math.log(v) - lx + (lx - 0.5) * Math.log(lx);
		return(y);
	}

	/**
	 * Incomplete gamma function upper side.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} gammaln_a
	 * @returns {number}
	 */
	static q_gamma(x, a, gammaln_a) {
		if(!isFinite(x)) {
			if(x === Infinity) {
				return 0.0;
			}
			else {
				return NaN;
			}
		}
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p227,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		let k;
		let result, w, temp, previous;
		// Laguerre&#x306E;&#x591A;&#x9805;&#x5F0F;
		let la = 1.0, lb = 1.0 + x - a;
		if(x &lt; 1.0 + a) {
			return (1 - Probability.p_gamma(x, a, gammaln_a));
		}
		w = Math.exp(a * Math.log(x) - x - gammaln_a);
		result = w / lb;
		for(k = 2; k &lt; 1000; k++) {
			temp = ((k - 1.0 - a) * (lb - la) + (k + x) * lb) / k;
			la = lb;
			lb = temp;
			w *= (k - 1.0 - a) / k;
			temp = w / (la * lb);
			previous = result;
			result += temp;
			if(result == previous) {
				return(result);
			}
		}
		return Number.NaN;
	}

	/**
	 * Incomplete gamma function lower side.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} gammaln_a
	 * @returns {number}
	 */
	static p_gamma(x, a, gammaln_a) {
		if(!isFinite(x)) {
			if(x === Infinity) {
				return 1.0;
			}
			else {
				return NaN;
			}
		}
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p227,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		let k;
		let result, term, previous;
		if(x &gt;= 1.0 + a) {
			return (1.0 - Probability.q_gamma(x, a, gammaln_a));
		}
		if(x === 0.0) {
			return 0.0;
		}
		result = term = Math.exp(a * Math.log(x) - x - gammaln_a) / a;
		for(k = 1; k &lt; 1000; k++) {
			term *= x / (a + k);
			previous = result;
			result += term;
			if(result == previous) {
				return result;
			}
		}
		return Number.NaN;
	}

	/**
	 * Gamma function.
	 * @param {number} z
	 * @returns {number}
	 */
	static gamma(z) {
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p30,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		if(z &lt; 0) {
			return (Math.PI / (Math.sin(Math.PI * z) * Math.exp(Probability.gammaln(1.0 - z))));
		}
		return Math.exp(Probability.gammaln(z));
	}

	/**
	 * Incomplete gamma function.
	 * @param {number} x
	 * @param {number} a
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {number}
	 */
	static gammainc(x, a, tail) {
		if(tail === &quot;lower&quot;) {
			return Probability.p_gamma(x, a, Probability.gammaln(a));
		}
		else if(tail === &quot;upper&quot;) {
			return Probability.q_gamma(x, a, Probability.gammaln(a));
		}
		else if(tail === undefined) {
			// &#x5F15;&#x6570;&#x3092;&#x7701;&#x7565;&#x3057;&#x305F;&#x5834;&#x5408;
			return Probability.gammainc(x, a, &quot;lower&quot;);
		}
		else {
			throw &quot;gammainc unsupported argument [&quot; + tail + &quot;]&quot;;
		}
	}
	
	/**
	 * Probability density function (PDF) of the gamma distribution.
	 * @param {number} x
	 * @param {number} k - Shape parameter.
	 * @param {number} s - Scale parameter.
	 * @returns {number}
	 */
	static gampdf(x, k, s) {
		if(x === -Infinity) {
			return 0.0;
		}
		let y = 1.0 / (Probability.gamma(k) * Math.pow(s, k));
		y *= Math.pow( x, k - 1);
		y *= Math.exp( - x / s );
		return y;
	}

	/**
	 * Cumulative distribution function (CDF) of gamma distribution.
	 * @param {number} x
	 * @param {number} k - Shape parameter.
	 * @param {number} s - Scale parameter.
	 * @returns {number}
	 */
	static gamcdf(x, k, s) {
		if(x &lt; 0) {
			return 0.0;
		}
		return Probability.gammainc(x / s, k);
	}
	
	/**
	 * Inverse function of cumulative distribution function (CDF) of gamma distribution.
	 * @param {number} p
	 * @param {number} k - Shape parameter.
	 * @param {number} s - Scale parameter.
	 * @returns {number}
	 */
	static gaminv(p, k, s) {
		if((p &lt; 0.0) || (p &gt; 1.0)) {
			return Number.NaN;
		}
		else if(p == 0.0) {
			return 0.0;
		}
		else if(p == 1.0) {
			return Number.POSITIVE_INFINITY;
		}
		const eps = 1.0e-12;
		// &#x521D;&#x671F;&#x5024;&#x3092;&#x6C7A;&#x3081;&#x308B;
		let y = k * s;
		// &#x5358;&#x8ABF;&#x5897;&#x52A0;&#x95A2;&#x6570;&#x306A;&#x306E;&#x3067;&#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x30FB;&#x30E9;&#x30D5;&#x30BD;&#x30F3;&#x6CD5;&#x3067;&#x89E3;&#x304F;
		// x_n+1 = x_n - f(x) / f&apos;(x)
		// &#x3053;&#x3053;&#x3067; f(x) &#x306F;&#x7D2F;&#x7A4D;&#x5206;&#x5E03;&#x95A2;&#x6570;&#x3001;f&apos;(x) &#x306F;&#x78BA;&#x7387;&#x5BC6;&#x5EA6;&#x95A2;&#x6570;
		// a = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; &#x2192; f(x)  = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; - a &#x3068;&#x7F6E;&#x304F;&#x3002;
		// a&#x306E;&#x5FAE;&#x5206;&#x306F;0&#x306A;&#x306E;&#x3067;&#x7121;&#x95A2;&#x4FC2;
		let delta, y2;
		for(let i = 0; i &lt; 100; i++) {
			y2 = y - ((Probability.gamcdf(y, k, s) - p) / Probability.gampdf(y, k, s));
			delta = y2 - y;
			if(Math.abs(delta) &lt;= eps) {
				break;
			}
			y = y2;
			if(y &lt; 0.0) {
				y = eps;
			}
		}
		return y;
	}

	/**
	 * Beta function.
	 * @param {number} x
	 * @param {number} y
	 * @returns {number}
	 */
	static beta(x, y) {
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p30,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		return (Math.exp(Probability.gammaln(x) + Probability.gammaln(y) - Probability.gammaln(x + y)));
	}
	
	/**
	 * Incomplete beta function lower side.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} b
	 * @returns {number}
	 */
	static p_beta(x, a, b) {
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;,&quot;C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;&quot;,p231,&#x6280;&#x8853;&#x8A55;&#x8AD6;&#x793E;,1991
		let k;
		let result, term, previous;
		if(a &lt;= 0.0) {
			return Number.POSITIVE_INFINITY;
		}
		if(b &lt;= 0.0) {
			if(x &lt; 1.0) {
				return 0.0;
			}
			else if(x === 1.0) {
				return 1.0;
			}
			else {
				return Number.POSITIVE_INFINITY;
			}
		}
		if(x &gt; (a + 1.0) / (a + b + 2.0)) {
			return (1.0 - Probability.p_beta(1.0 - x, b, a));
		}
		if(x &lt;= 0.0) {
			return 0.0;
		}
		term = a * Math.log(x);
		term += b * Math.log(1.0 - x);
		term += Probability.gammaln(a + b);
		term -= Probability.gammaln(a) + Probability.gammaln(b);
		term = Math.exp(term);
		term /= a;
		result = term;
		for(k = 1; k &lt; 1000; k++) {
			term *= a + b + k - 1.0;
			term *= x;
			term /= a + k;
			previous = result;
			result += term;
			if(result === previous) {
				return result;
			}
		}
		return Number.NaN;
	}

	/**
	 * Incomplete beta function upper side.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} b
	 * @returns {number}
	 */
	static q_beta(x, a, b) {
		return (1.0 - Probability.p_beta(x, a, b));
	}

	/**
	 * Incomplete beta function.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} b
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {number}
	 */
	static betainc(x, a, b, tail) {
		if(tail === &quot;lower&quot;) {
			return Probability.p_beta(x, a, b);
		}
		else if(tail === &quot;upper&quot;) {
			return Probability.q_beta(x, a, b);
		}
		else if(tail === undefined) {
			// &#x5F15;&#x6570;&#x3092;&#x7701;&#x7565;&#x3057;&#x305F;&#x5834;&#x5408;
			return Probability.betainc(x, a, b, &quot;lower&quot;);
		}
		else {
			throw &quot;betainc unsupported argument [&quot; + tail + &quot;]&quot;;
		}
	}
	
	/**
	 * Probability density function (PDF) of beta distribution.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} b
	 * @returns {number}
	 */
	static betapdf(x, a, b) {
		// pow&#x306E;&#x8A08;&#x7B97;&#x7D50;&#x679C;&#x304C;&#x8907;&#x7D20;&#x6570;&#x306B;&#x306A;&#x308B;&#x5834;&#x5408;&#x306F;&#x8A08;&#x7B97;&#x3092;&#x884C;&#x308F;&#x306A;&#x3044;
		if	(
			((x &lt; 0) &amp;&amp; isInteger(b - 1)) ||
			((1 - x &lt; 0) &amp;&amp; isInteger(b - 1))
		) {
			return 0.0;
		}
		// &#x4EE5;&#x4E0B;&#x306E;&#x5F0F;&#x3067;&#x3082;&#x6C42;&#x3081;&#x3089;&#x308C;&#x308B;&#x304C; betapdf(0, 1, 1)&#x3067;&#x3001;Log(0)&#x306E;&#x8A08;&#x7B97;&#x304C;&#x767A;&#x751F;&#x3057;NaN&#x3092;&#x8FD4;&#x3057;&#x3066;&#x3057;&#x307E;&#x3046;&#x3002;&#x5B9F;&#x969B;&#x306F;1&#x3092;&#x8FD4;&#x3059;&#x3079;&#x304D;&#x3002;
		//return(Math.exp((a - 1) * Math.log(x) + (b - 1) * Math.log(1 - x)) / Probability.beta(a,  b));
		return (Math.pow(x, a - 1) * Math.pow(1 - x, b - 1) / Probability.beta(a,  b));
	}

	/**
	 * Cumulative distribution function (CDF) of beta distribution.
	 * @param {number} x
	 * @param {number} a
	 * @param {number} b
	 * @returns {number}
	 */
	static betacdf(x, a, b) {
		return Probability.betainc(x, a, b);
	}
	
	/**
	 * Inverse function of cumulative distribution function (CDF) of beta distribution.
	 * @param {number} p
	 * @param {number} a
	 * @param {number} b
	 * @returns {number}
	 */
	static betainv(p, a, b) {
		if((p &lt; 0.0) || (p &gt; 1.0)) {
			return Number.NaN;
		}
		else if((p == 0.0) &amp;&amp; (a &gt; 0.0) &amp;&amp; (b &gt; 0.0)) {
			return 0.0;
		}
		else if((p == 1.0) &amp;&amp; (a &gt; 0.0) &amp;&amp; (b &gt; 0.0)) {
			return 1.0;
		}
		const eps = 1.0e-14;
		// &#x521D;&#x671F;&#x5024;&#x3092;&#x6C7A;&#x3081;&#x308B;
		let y;
		if(b == 0) {
			y = 1.0 - eps;
		}
		else if(a == 0) {
			y = eps;
		}
		else {
			y = a / (a + b);
		}
		// &#x5358;&#x8ABF;&#x5897;&#x52A0;&#x95A2;&#x6570;&#x306A;&#x306E;&#x3067;&#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x30FB;&#x30E9;&#x30D5;&#x30BD;&#x30F3;&#x6CD5;&#x3067;&#x89E3;&#x304F;
		// x_n+1 = x_n - f(x) / f&apos;(x)
		// &#x3053;&#x3053;&#x3067; f(x) &#x306F;&#x7D2F;&#x7A4D;&#x5206;&#x5E03;&#x95A2;&#x6570;&#x3001;f&apos;(x) &#x306F;&#x78BA;&#x7387;&#x5BC6;&#x5EA6;&#x95A2;&#x6570;
		// a = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; &#x2192; f(x)  = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; - a &#x3068;&#x7F6E;&#x304F;&#x3002;
		// a&#x306E;&#x5FAE;&#x5206;&#x306F;0&#x306A;&#x306E;&#x3067;&#x7121;&#x95A2;&#x4FC2;
		let delta, y2;
		for(let i = 0; i &lt; 100; i++) {
			y2 = y - ((Probability.betacdf(y, a, b) - p) / Probability.betapdf(y, a, b));
			delta = y2 - y;
			if(Math.abs(delta) &lt;= eps) {
				break;
			}
			y = y2;
			if(y &gt; 1.0) {
				y = 1.0 - eps;
			}
			else if(y &lt; 0.0) {
				y = eps;
			}
		}
		return y;
	}

	/**
	 * Factorial function, x!.
	 * @param {number} n
	 * @returns {number}
	 */
	static factorial(n) {
		const y = Probability.gamma(n + 1.0);
		if(Math.trunc(n) === n) {
			return Math.round(y);
		}
		else {
			return y;
		}
	}

	/**
	 * Binomial coefficient, number of all combinations, nCk.
	 * @param {number} n
	 * @param {number} k
	 * @returns {number} nCk
	 */
	static nchoosek(n, k) {
		// &#x5C11;&#x306A;&#x3044;&#x6570;&#x5B57;&#x306A;&#x3089;&#x4EE5;&#x4E0B;&#x306E;&#x8A08;&#x7B97;&#x3067;&#x3088;&#x3044;
		// return Math.round(Probability.factorial(n) / (Probability.factorial(n - k) * Probability.factorial(k)));
		let x = 1;
		const new_k = Math.min(k, n - k);
		for(let i = 1; i &lt;= new_k; i++) {
			x *= (n + 1 - i) / i;
			if(x &gt;= Number.MAX_SAFE_INTEGER) {
				return Infinity;
			}
		}
		return x;
	}

	/**
	 * Error function.
	 * @param {number} x
	 * @returns {number}
	 */
	static erf(x) {
		return (Probability.p_gamma(x * x, 0.5, Math.log(Math.PI) * 0.5) * (x &gt;= 0 ? 1.0 : -1.0));
	}

	/**
	 * Complementary error function.
	 * @param {number} x
	 * @returns {number}
	 */
	static erfc(x) {
		return 1.0 - Probability.erf(x);
	}

	/**
	 * Inverse function of error function.
	 * @param {number} p
	 * @returns {number}
	 */
	static erfinv(p) {
		return Probability.erfcinv(1.0 - p);
	}

	/**
	 * Inverse function of complementary error function.
	 * @param {number} p
	 * @returns {number}
	 */
	static erfcinv(p) {
		return - Probability.norminv(p * 0.5) / Math.sqrt(2);
	}

	/**
	 * Probability density function (PDF) of normal distribution.
	 * @param {number} x
	 * @param {number} [u=0.0] - Average value.
	 * @param {number} [s=1.0] - Variance value.
	 * @returns {number}
	 */
	static normpdf(x, u, s) {
		const u_ = typeof u === &quot;number&quot; ? u : 0.0;
		const s_ = typeof s === &quot;number&quot; ? s : 1.0;
		let y = 1.0 / Math.sqrt( 2.0 * Math.PI * s_ * s_ );
		y *= Math.exp( - (x - u_) * (x - u_) / (2.0 * s_ * s_));
		return y;
	}

	/**
	 * Cumulative distribution function (CDF) of normal distribution.
	 * @param {number} x
	 * @param {number} [u=0.0] - Average value.
	 * @param {number} [s=1.0] - Variance value.
	 * @returns {number}
	 */
	static normcdf(x, u, s) {
		const u_ = typeof u === &quot;number&quot; ? u : 0.0;
		const s_ = typeof s === &quot;number&quot; ? s : 1.0;
		return (1.0 + Probability.erf( (x - u_) / (s_ * Math.sqrt(2.0)) )) / 2.0;
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of normal distribution.
	 * @param {number} p - Probability.
	 * @param {number} [u=0.0] - Average value.
	 * @param {number} [s=1.0] - Variance value.
	 * @returns {number}
	 */
	static norminv(p, u, s) {
		if((p &lt; 0.0) || (p &gt; 1.0)) {
			return Number.NaN;
		}
		else if(p == 0.0) {
			return Number.NEGATIVE_INFINITY;
		}
		else if(p == 1.0) {
			return Number.POSITIVE_INFINITY;
		}
		const u_ = typeof u === &quot;number&quot; ? u : 0.0;
		const s_ = typeof s === &quot;number&quot; ? s : 1.0;
		const eps = 1.0e-12;
		// &#x521D;&#x671F;&#x5024;&#x3092;&#x6C7A;&#x3081;&#x308B;
		let y = u_;
		// &#x5358;&#x8ABF;&#x5897;&#x52A0;&#x95A2;&#x6570;&#x306A;&#x306E;&#x3067;&#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x30FB;&#x30E9;&#x30D5;&#x30BD;&#x30F3;&#x6CD5;&#x3067;&#x89E3;&#x304F;
		// x_n+1 = x_n - f(x) / f&apos;(x)
		// &#x3053;&#x3053;&#x3067; f(x) &#x306F;&#x7D2F;&#x7A4D;&#x5206;&#x5E03;&#x95A2;&#x6570;&#x3001;f&apos;(x) &#x306F;&#x78BA;&#x7387;&#x5BC6;&#x5EA6;&#x95A2;&#x6570;
		// a = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; &#x2192; f(x)  = &#x7D2F;&#x7A4D;&#x5206;&#x95A2;&#x6570; - a &#x3068;&#x7F6E;&#x304F;&#x3002;
		// a&#x306E;&#x5FAE;&#x5206;&#x306F;0&#x306A;&#x306E;&#x3067;&#x7121;&#x95A2;&#x4FC2;
		let delta, y2;
		for(let i = 0; i &lt; 200; i++) {
			y2 = y - ((Probability.normcdf(y, u_, s_) - p) / Probability.normpdf(y, u_, s_));
			delta = y2 - y;
			if(Math.abs(delta) &lt;= eps) {
				break;
			}
			y = y2;
		}
		return y;
	}

	/**
	 * Probability density function (PDF) of binomial distribution.
	 * @param {number} x
	 * @param {number} n
	 * @param {number} p
	 * @returns {number}
	 */
	static binopdf(x, n, p) {
		if(!isFinite(p)) {
			if(isNaN(p)) {
				return NaN;
			}
			else {
				return 0.0;
			}
		}
		return Probability.nchoosek(n, x) * Math.pow(p, x) * Math.pow(1.0 - p, n - x);
	}
	
	/**
	 * Cumulative distribution function (CDF) of binomial distribution.
	 * @param {number} x
	 * @param {number} n
	 * @param {number} p
	 * @param {string} [tail=&quot;lower&quot;] - lower (default) , &quot;upper&quot;
	 * @returns {number}
	 */
	static binocdf(x, n, p, tail) {
		return Probability.betainc(1.0 - p, n - Math.floor(x), 1 + Math.floor(x), tail);
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of binomial distribution.
	 * @param {number} y
	 * @param {number} n
	 * @param {number} p
	 * @returns {number}
	 */
	static binoinv(y, n, p) {
		if((y &lt; 0.0) || (1.0 &lt; y) || (p &lt; 0.0) || (1.0 &lt; p)) {
			return Number.NaN;
		}
		else if((y == 0.0) || (p == 0.0)) {
			return 0.0;
		}
		else if(p == 1.0) {
			return n;
		}
		// &#x521D;&#x671F;&#x5024;&#x3092;&#x6C7A;&#x3081;&#x308B;
		let min = 1;
		let max = n;
		let middle = 0, old_middle = 0; 
		// &#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x30E9;&#x30D5;&#x30BD;&#x30F3;&#x6CD5;&#x3060;&#x3068;&#x5B89;&#x5B9A;&#x3057;&#x306A;&#x3044;&#x306E;&#x3067;
		// &#x631F;&#x307F;&#x8FBC;&#x307F;&#x6CD5;&#xFF08;&#x4E8C;&#x5206;&#x6CD5;&#xFF09;&#x3067;&#x6C42;&#x3081;&#x308B;
		for(let i = 0; i &lt; 200; i++) {
			middle = Math.round((min + max) / 2);
			const Y = Probability.binocdf(middle, n, p);
			if(middle === old_middle) {
				break;
			}
			if(Y &gt; y) {
				max = middle;
			}
			else {
				min = middle;
			}
			old_middle = middle;
		}
		return middle;
	}

	/**
	 * Probability density function (PDF) of Poisson distribution.
	 * @param {number} k
	 * @param {number} lambda
	 * @returns {number}
	 */
	static poisspdf(k, lambda) {
		if(!isFinite(k)) {
			if(isNaN(k)) {
				return Number.NaN;
			}
			else {
				return 0.0;
			}
		}
		// k &#x304C;&#x5927;&#x304D;&#x3044;&#x3068;Inf&#x306B;&#x306A;&#x3063;&#x3066;&#x3057;&#x307E;&#x3046;&#x306E;&#x3067;&#x4EE5;&#x4E0B;&#x306E;&#x51E6;&#x7406;&#x306F;&#x3060;&#x3081;
		// Math.pow(lambda, k) * Math.exp( - lambda ) / Probability.factorial(k);
		// &#x3042;&#x3075;&#x308C;&#x306A;&#x3044;&#x3088;&#x3046;&#x306B;&#x8ABF;&#x6574;&#x3057;&#x306A;&#x304C;&#x3089;&#x3001;&#x5730;&#x9053;&#x306B;&#x8A08;&#x7B97;&#x3059;&#x308B;&#x3002;
		const inv_e = 1.0 / Math.E;
		let x = 1.0;
		let lambda_i = 0;
		for(let i = 1; i &lt;= k; i++) {
			x = x * lambda / i;
			if(lambda_i &lt; lambda) {
				x *= inv_e;
				lambda_i++;
			}
		}
		for(; lambda_i &lt; lambda; lambda_i++) {
			x *= inv_e;
		}
		return x;
	}
	
	/**
	 * Cumulative distribution function (CDF) of Poisson distribution.
	 * @param {number} k
	 * @param {number} lambda
	 * @returns {number}
	 */
	static poisscdf(k, lambda) {
		if(k &lt; 0) {
			return 0;
		}
		return 1.0 - Probability.gammainc(lambda, Math.floor(k + 1));
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of Poisson distribution.
	 * @param {number} p
	 * @param {number} lambda
	 * @returns {number}
	 */
	static poissinv(p, lambda) {
		if((p &lt; 0.0) || (1.0 &lt; p)) {
			return Number.NaN;
		}
		else if(p == 0.0) {
			return 0.0;
		}
		else if(p == 1.0) {
			return Number.POSITIVE_INFINITY;
		}
		// &#x521D;&#x671F;&#x5024;&#x3092;&#x6C7A;&#x3081;&#x308B;
		let min = 1;
		let max = lambda * 20;
		let middle = 0, old_middle = 0; 
		// &#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x30E9;&#x30D5;&#x30BD;&#x30F3;&#x6CD5;&#x3060;&#x3068;&#x5B89;&#x5B9A;&#x3057;&#x306A;&#x3044;&#x306E;&#x3067;
		// &#x631F;&#x307F;&#x8FBC;&#x307F;&#x6CD5;&#xFF08;&#x4E8C;&#x5206;&#x6CD5;&#xFF09;&#x3067;&#x6C42;&#x3081;&#x308B;
		for(let i = 0; i &lt; 200; i++) {
			middle = Math.round((min + max) / 2);
			const P = Probability.poisscdf(middle, lambda);
			if(middle === old_middle) {
				break;
			}
			if(P &gt; p) {
				max = middle;
			}
			else {
				min = middle;
			}
			old_middle = middle;
			// console.log(i + &quot; &quot; + min + &quot; &quot; + P + &quot; &quot; + max);
		}
		return middle;
	}

	/**
	 * Probability density function (PDF) of Student&apos;s t-distribution.
	 * @param {number} t - T-value.
	 * @param {number} v - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static tpdf(t, v) {
		let y = 1.0 / (Math.sqrt(v) * Probability.beta(0.5, v * 0.5));
		y *= Math.pow( 1 + t * t / v, - (v + 1) * 0.5);
		return y;
	}

	/**
	 * Cumulative distribution function (CDF) of Student&apos;s t-distribution.
	 * @param {number} t - T-value.
	 * @param {number} v - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static tcdf(t, v) {
		const y = (t * t) / (v + t * t) ;
		const p = Probability.betainc( y, 0.5, v * 0.5 ) * (t &lt; 0 ? -1 : 1);
		return 0.5 * (1 + p);
	}

	/**
	 * Inverse of cumulative distribution function (CDF) of Student&apos;s t-distribution.
	 * @param {number} p - Probability.
	 * @param {number} v - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static tinv(p, v) {
		if((p &lt; 0) || (p &gt; 1)) {
			return Number.NaN;
		}
		if(p == 0) {
			return Number.NEGATIVE_INFINITY;
		}
		else if(p == 1) {
			return Number.POSITIVE_INFINITY;
		}
		else if(p &lt; 0.5) {
			const y = Probability.betainv(2.0 * p, 0.5 * v, 0.5);
			return - Math.sqrt(v / y - v);
		}
		else {
			const y = Probability.betainv(2.0 * (1.0 - p), 0.5 * v, 0.5);
			return Math.sqrt(v / y - v);
		}
	}

	/**
	 * Cumulative distribution function (CDF) of Student&apos;s t-distribution that can specify tail.
	 * @param {number} t - T-value.
	 * @param {number} v - The degrees of freedom. (DF)
	 * @param {number} tails - Tail. (1 = the one-tailed distribution, 2 =  the two-tailed distribution.)
	 * @returns {number}
	 */
	static tdist(t, v, tails) {
		return (1.0 - Probability.tcdf(Math.abs(t), v)) * tails;
	}

	/**
	 * Inverse of cumulative distribution function (CDF) of Student&apos;s t-distribution in two-sided test.
	 * @param {number} p - Probability.
	 * @param {number} v - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static tinv2(p, v) {
		return - Probability.tinv( p * 0.5, v);
	}

	/**
	 * Probability density function (PDF) of chi-square distribution.
	 * @param {number} x 
	 * @param {number} k - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static chi2pdf(x, k) {
		if(x &lt; 0.0) {
			return 0;
		}
		else if(x === 0.0) {
			return 0.5;
		}
		let y = Math.pow(x, k / 2.0 - 1.0) * Math.exp( - x / 2.0 );
		y /= Math.pow(2, k / 2.0) * Probability.gamma( k / 2.0);
		return y;
	}

	/**
	 * Cumulative distribution function (CDF) of chi-square distribution.
	 * @param {number} x 
	 * @param {number} k - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static chi2cdf(x, k) {
		return Probability.gammainc(x / 2.0, k / 2.0);
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of chi-square distribution.
	 * @param {number} p - Probability.
	 * @param {number} k - The degrees of freedom. (DF)
	 * @returns {number}
	 */
	static chi2inv(p, k) {
		return Probability.gaminv(p, k / 2.0, 2);
	}

	/**
	 * Probability density function (PDF) of F-distribution.
	 * @param {number} x
	 * @param {number} d1 - The degree of freedom of the molecules.
	 * @param {number} d2 - The degree of freedom of the denominator
	 * @returns {number}
	 */
	static fpdf(x, d1, d2) {
		if((d1 &lt; 0) || (d2 &lt; 0)) {
			return Number.NaN;
		}
		else if(x &lt;= 0) {
			return 0.0;
		}
		let y = 1.0;
		y *= Math.pow( (d1 * x) / (d1 * x + d2) , d1 / 2.0);
		y *= Math.pow( 1.0 - ((d1 * x) / (d1 * x + d2)), d2 / 2.0);
		y /= x * Probability.beta(d1 / 2.0, d2 / 2.0);
		return y;
	}

	/**
	 * Cumulative distribution function (CDF) of F-distribution.
	 * @param {number} x
	 * @param {number} d1 - The degree of freedom of the molecules.
	 * @param {number} d2 - The degree of freedom of the denominator
	 * @returns {number}
	 */
	static fcdf(x, d1, d2) {
		return Probability.betacdf( d1 * x / (d1 * x + d2), d1 / 2.0, d2 / 2.0 );
	}

	/**
	 * Inverse function of cumulative distribution function (CDF) of F-distribution.
	 * @param {number} p - Probability.
	 * @param {number} d1 - The degree of freedom of the molecules.
	 * @param {number} d2 - The degree of freedom of the denominator
	 * @returns {number}
	 */
	static finv(p, d1, d2) {
		return (1.0 / Probability.betainv( 1.0 - p, d2 / 2.0, d1 / 2.0 ) - 1.0) * d2 / d1;
	}

}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
